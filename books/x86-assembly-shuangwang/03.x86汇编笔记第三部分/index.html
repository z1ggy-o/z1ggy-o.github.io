<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Note - x86 汇编语言（3）：多任务支持 | Gy's Blog</title>
<meta name=keywords content="Computer Organization"><meta name=description content="
这是系列笔记的第三篇。在上一篇中，我们介绍了保护模式基于段选择子的寻址方式，这一篇中我们来讲一讲该架构的另一个特点，多任务支持。
其余章节如下：

第一部分: 计算机基础和实模式
第二部分：保护模式下的分段寻址和权限
第三部分：多任务支持
第四部分：分页机制

任务：运行程序的表达
在之前的篇章中我们尽量避免了任务概念的出现。在 80286 之前，计算机主要以单任务（single-tasking）的方式运行。即，先集中于完成一个程序的运行，再运行下一个程序。有些类似于最初 mainframe 的 batching 的感觉。80286 首次在处理器硬件上提供了对多任务的支持，80386 时期多任务得到了广泛的应用。"><meta name=author content="Me"><link rel=canonical href=https://z1ggy-o.github.io/books/x86-assembly-shuangwang/03.x86%E6%B1%87%E7%BC%96%E7%AC%94%E8%AE%B0%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86/><link crossorigin=anonymous href=/assets/css/stylesheet.d6fcd20a4fb86efa4dfac8ec95da60244cc8871042183da1ef28e3a762ad79c8.css integrity="sha256-1vzSCk+4bvpN+sjsldpgJEzIhxBCGD2h7yjjp2Ktecg=" rel="preload stylesheet" as=style><link rel=icon href=https://z1ggy-o.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://z1ggy-o.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://z1ggy-o.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://z1ggy-o.github.io/apple-touch-icon.png><link rel=mask-icon href=https://z1ggy-o.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://z1ggy-o.github.io/books/x86-assembly-shuangwang/03.x86%E6%B1%87%E7%BC%96%E7%AC%94%E8%AE%B0%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://z1ggy-o.github.io/books/x86-assembly-shuangwang/03.x86%E6%B1%87%E7%BC%96%E7%AC%94%E8%AE%B0%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86/"><meta property="og:site_name" content="Gy's Blog"><meta property="og:title" content="Note - x86 汇编语言（3）：多任务支持"><meta property="og:description" content=" 这是系列笔记的第三篇。在上一篇中，我们介绍了保护模式基于段选择子的寻址方式，这一篇中我们来讲一讲该架构的另一个特点，多任务支持。
其余章节如下：
第一部分: 计算机基础和实模式 第二部分：保护模式下的分段寻址和权限 第三部分：多任务支持 第四部分：分页机制 任务：运行程序的表达 在之前的篇章中我们尽量避免了任务概念的出现。在 80286 之前，计算机主要以单任务（single-tasking）的方式运行。即，先集中于完成一个程序的运行，再运行下一个程序。有些类似于最初 mainframe 的 batching 的感觉。80286 首次在处理器硬件上提供了对多任务的支持，80386 时期多任务得到了广泛的应用。"><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="books"><meta property="article:published_time" content="2022-07-06T08:44:20+00:00"><meta property="article:modified_time" content="2024-12-28T10:32:24+00:00"><meta property="article:tag" content="Computer Organization"><meta name=twitter:card content="summary"><meta name=twitter:title content="Note - x86 汇编语言（3）：多任务支持"><meta name=twitter:description content="
这是系列笔记的第三篇。在上一篇中，我们介绍了保护模式基于段选择子的寻址方式，这一篇中我们来讲一讲该架构的另一个特点，多任务支持。
其余章节如下：

第一部分: 计算机基础和实模式
第二部分：保护模式下的分段寻址和权限
第三部分：多任务支持
第四部分：分页机制

任务：运行程序的表达
在之前的篇章中我们尽量避免了任务概念的出现。在 80286 之前，计算机主要以单任务（single-tasking）的方式运行。即，先集中于完成一个程序的运行，再运行下一个程序。有些类似于最初 mainframe 的 batching 的感觉。80286 首次在处理器硬件上提供了对多任务的支持，80386 时期多任务得到了广泛的应用。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Books","item":"https://z1ggy-o.github.io/books/"},{"@type":"ListItem","position":2,"name":"x86 汇编语言 - 王爽","item":"https://z1ggy-o.github.io/books/x86-assembly-shuangwang/"},{"@type":"ListItem","position":3,"name":"Note - x86 汇编语言（3）：多任务支持","item":"https://z1ggy-o.github.io/books/x86-assembly-shuangwang/03.x86%E6%B1%87%E7%BC%96%E7%AC%94%E8%AE%B0%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Note - x86 汇编语言（3）：多任务支持","name":"Note - x86 汇编语言（3）：多任务支持","description":" 这是系列笔记的第三篇。在上一篇中，我们介绍了保护模式基于段选择子的寻址方式，这一篇中我们来讲一讲该架构的另一个特点，多任务支持。\n其余章节如下：\n第一部分: 计算机基础和实模式 第二部分：保护模式下的分段寻址和权限 第三部分：多任务支持 第四部分：分页机制 任务：运行程序的表达 在之前的篇章中我们尽量避免了任务概念的出现。在 80286 之前，计算机主要以单任务（single-tasking）的方式运行。即，先集中于完成一个程序的运行，再运行下一个程序。有些类似于最初 mainframe 的 batching 的感觉。80286 首次在处理器硬件上提供了对多任务的支持，80386 时期多任务得到了广泛的应用。\n","keywords":["Computer Organization"],"articleBody":" 这是系列笔记的第三篇。在上一篇中，我们介绍了保护模式基于段选择子的寻址方式，这一篇中我们来讲一讲该架构的另一个特点，多任务支持。\n其余章节如下：\n第一部分: 计算机基础和实模式 第二部分：保护模式下的分段寻址和权限 第三部分：多任务支持 第四部分：分页机制 任务：运行程序的表达 在之前的篇章中我们尽量避免了任务概念的出现。在 80286 之前，计算机主要以单任务（single-tasking）的方式运行。即，先集中于完成一个程序的运行，再运行下一个程序。有些类似于最初 mainframe 的 batching 的感觉。80286 首次在处理器硬件上提供了对多任务的支持，80386 时期多任务得到了广泛的应用。\n所谓任务，就是我们所熟知的进程。它是一个运行中的程序的抽象表达。我们知道，一个处理器只能在一个时间内运行一个指令。所以，多个程序的“同时”运行是一个假象。它的本质是处理器为各个程序分别运行一段时间，然后快速地在各个程序之间切换。\n一个程序在运行的时候，它会使用到计算机的各个部件，或者叫资源。要在多个程序之间快速切换，不仅要切走，还要能切回来。即，我们在载入其他程序之前，需要把当前程序所用到的资源保存起来，这样以后才能被重新载入，继续运行。这些与一个运行的程序相关的资源，可以叫做 context。所以，我们也会把任务切换叫做 context switching。\n这些与一个任务相关的信息被存放在一个叫做 Task State Segment (TSS) 的内存区域中，它的格式和保存的内容如下：\n任务间隔离 在上一篇中我们提到，保护模式下，我们使用段选择子从段描述符表中获取段描述符的方式来进行寻址。我们也提到了一个系统全局的描述符表，GDT。\n但是，如果仅有一个 GDT，基于段的保护措施是无法实现真正的保护的。因为每个任务都需要访问段描述符表来进行寻址，那么 GDT 所在的内存区间需要对所有的任何开放。其结果就是，一个任务可以访问同级别或低级别其他任务的段，只需出给相应段的段选择子就好了。\n为了杜绝任务间的非法访问，我们不能让每个程序都通过 GDT 来进行寻址，而是让每个任务有自己的一个描述符表，这就是 Local Descriptor Table (LDT)。\nLDT 在结构上和 GDT 没有不同，只是每个任务都有自己单独的 LDT，而且进行内存访问的时候只能使用自己的 LDT 来进行。因为 LDT 内只有和该任务自己相关的描述符存在，上述问题就得到了解决。\n处理器对支持多任务所做的设计 为了应对多任务，我们引入了 TSS 和 LDT。那么为了便捷地找到 TSS 和 LDT 我们的处理器就增加了两个相应的寄存器：TR 和 LDTR。\nTR 寄存器中我们存放当前任务 TSS 的地址，LDTR 中我们存放当前任务 LDT 的地址。段选择子中有一个 TI 位，指明我们需要使用 GDT 还是 LDT 进行寻址。\n在实际的运行过程中，任务间的切换是相当频繁的。为了提高切换的速度，处理器会协助我们进行任务切换。具体的来说，只要我们给出想要切换的目标任务的 TSS，处理器会自动帮我们存储当前任务的信息，并且载入目标任务的信息。\n如何管理任务 任务的切换由处理器来协助，但是什么时候进行切换，切换到哪一个任务是由操作系统说了算的。\n为了进行任务调度，操作系统需要维护各个任务相关的信息，当前其中必须要有 TSS 和 LDT 的位置信息。所以，操作系统需要有一个内存区域来存放关于任务的信息，这个区域就叫做 Task Control Block (TCB)。\nTCB 并不是处理器的工作要求，而是存粹的操作系统软件内容，所以，每个操作系统都可以设计自己管理 TCB 的方式，以及存放的信息。最最简单的模型就是，TCB 中只有 TSS 和 LDT 域，然后每个 TCB 用链表连接起来。当然，实际生活中的操作系统会用更加成熟高效的管理方式。\n如何进行任务切换 任务切换有两种方式：\n协同式：即当前工作的任务主动放弃执行权；或者在其通过调用门请求操作系统系统服务的时候，由操作系统趁机把控制转换到另外的任务。 抢占式：一般情况下，是利用定时器中断，并在中断服务程序中实施任务切换。因为硬件中断信号总是会定时出现，任务切换总能够进行。 使用控制转移指令，我们可以进行协同式的切换；利用中断，我们可以进行抢占式的中断。\n这里追加一个信息。前一章中我们提到，可以使用调用门来进行特权转换。实际上，除了调用门之外，我们还有三类与中断相关的门，它们被存放在中断描述符表（IDT）中：\n中断门 陷阱门 任务门 中断门和陷阱门在一般的中断处理中使用，指向的是处理函数的代码段选择子和段内偏移；而任务门则是用来进行任务切换的，存放着任务的 TSS 选择子。\n利用控制转移指令进行任务切换 我们可以利用 call 和 jmp 指令并给出一个 GDT 中的 TSS 描述符。处理器转移过程中，发现对象是 TSS 描述符，就会相应的进行任务切换。\n相似的，我们也可以利用 call 和 jmp 指令并给出一个任务门描述符。处理器判断出描述符指向任务门后，进行相应的任务切换。\n利用异常和中断进行切换 如果异常或中断发生的时候，中断号指向的是中断描述符表中的任务门，处理器会进行相应的切换。\n使用中断的时候有一个要点，即，不论是中断门，陷阱门，还是任务门，它们都是中断相关，所以最后都是用 iret 指令返回。前者是返回同一个任务的不同代码段，后者是返回到之前被中断暂停的任务。那么问题是，处理器如何知道自己该怎么做呢？\n答案在 EFLAGS 寄存器的 NT 位上。NT 即 Nested，如果 NT 位被置为 1，则说明当前的任务是嵌套于其他任务，或者说，是从其他任务切换而来的。\n处理器每次执行 iret 指令的时候都会检测当前 EFLAGS 寄存器的 NT 位。如果是 0 则说明是中断，直接返回即可；如果是 1 说明是任务切换，需要保存当前任务信息并载入之前的任务（之前任务的 TSS 位置被记录在当前任务的 TSS 中）。\n这里也仅仅是简单地做一个介绍，实际的运行过程中还有相应的权限检测等内容。有需要的话请参照手册学习。\n总结 任务是一个运行中的程序的逻辑表达。也就是所谓的进程。 为了支持多任务，我们引入了 TSS 来存放一个任务的运行环境信息，以及 LDT 来进行任务间的空间隔离。 处理器在任务切换的时候会自动地帮助我们存储当前任务的信息，并载入新任务。但是什么时候进行任务切换，切换哪个任务，是由操作系统控制的。 ","wordCount":"2395","inLanguage":"en","datePublished":"2022-07-06T08:44:20Z","dateModified":"2024-12-28T10:32:24.596832969Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://z1ggy-o.github.io/books/x86-assembly-shuangwang/03.x86%E6%B1%87%E7%BC%96%E7%AC%94%E8%AE%B0%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86/"},"publisher":{"@type":"Organization","name":"Gy's Blog","logo":{"@type":"ImageObject","url":"https://z1ggy-o.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://z1ggy-o.github.io/ accesskey=h title="Gy's Blog (Alt + H)">Gy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://z1ggy-o.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://z1ggy-o.github.io/weekly/ title=Logs><span>Logs</span></a></li><li><a href=https://z1ggy-o.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://z1ggy-o.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://z1ggy-o.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://z1ggy-o.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://z1ggy-o.github.io/books/>Books</a>&nbsp;»&nbsp;<a href=https://z1ggy-o.github.io/books/x86-assembly-shuangwang/>x86 汇编语言 - 王爽</a></div><h1 class="post-title entry-hint-parent">Note - x86 汇编语言（3）：多任务支持</h1><div class=post-meta><span title='2022-07-06 08:44:20 +0000 UTC'>July 6, 2022</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;Me</div></header><div class=post-content><hr><p>这是系列笔记的第三篇。在上一篇中，我们介绍了保护模式基于段选择子的寻址方式，这一篇中我们来讲一讲该架构的另一个特点，多任务支持。</p><p>其余章节如下：</p><ul><li><a href=../01.x86%E6%B1%87%E7%BC%96%E7%AC%94%E8%AE%B0%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86/>第一部分: 计算机基础和实模式</a></li><li><a href=02.x86%E6%B1%87%E7%BC%96%E7%AC%94%E8%AE%B0%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86/>第二部分：保护模式下的分段寻址和权限</a></li><li><a href=03.x86%E6%B1%87%E7%BC%96%E7%AC%94%E8%AE%B0%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86/>第三部分：多任务支持</a></li><li><a href=04.x86%E6%B1%87%E7%BC%96%E7%AC%94%E8%AE%B0%E7%AC%AC%E5%9B%9B%E9%83%A8%E5%88%86/>第四部分：分页机制</a></li></ul><h2 id=任务运行程序的表达>任务：运行程序的表达<a hidden class=anchor aria-hidden=true href=#任务运行程序的表达>#</a></h2><p>在之前的篇章中我们尽量避免了任务概念的出现。在 80286 之前，计算机主要以单任务（single-tasking）的方式运行。即，先集中于完成一个程序的运行，再运行下一个程序。有些类似于最初 mainframe 的 batching 的感觉。80286 首次在处理器硬件上提供了对多任务的支持，80386 时期多任务得到了广泛的应用。</p><p>所谓任务，就是我们所熟知的进程。它是一个运行中的程序的抽象表达。我们知道，一个处理器只能在一个时间内运行一个指令。所以，多个程序的“同时”运行是一个假象。它的本质是处理器为各个程序分别运行一段时间，然后快速地在各个程序之间切换。</p><p>一个程序在运行的时候，它会使用到计算机的各个部件，或者叫资源。要在多个程序之间快速切换，不仅要切走，还要能切回来。即，我们在载入其他程序之前，需要把当前程序所用到的资源保存起来，这样以后才能被重新载入，继续运行。这些与一个运行的程序相关的资源，可以叫做 context。所以，我们也会把任务切换叫做 context switching。</p><p>这些与一个任务相关的信息被存放在一个叫做 Task State Segment (TSS) 的内存区域中，它的格式和保存的内容如下：</p><h2 id=任务间隔离>任务间隔离<a hidden class=anchor aria-hidden=true href=#任务间隔离>#</a></h2><p>在上一篇中我们提到，保护模式下，我们使用段选择子从段描述符表中获取段描述符的方式来进行寻址。我们也提到了一个系统全局的描述符表，GDT。</p><p>但是，如果仅有一个 GDT，基于段的保护措施是无法实现真正的保护的。因为每个任务都需要访问段描述符表来进行寻址，那么 GDT 所在的内存区间需要对所有的任何开放。其结果就是，一个任务可以访问同级别或低级别其他任务的段，只需出给相应段的段选择子就好了。</p><p>为了杜绝任务间的非法访问，我们不能让每个程序都通过 GDT 来进行寻址，而是让每个任务有自己的一个描述符表，这就是 Local Descriptor Table (LDT)。</p><p>LDT 在结构上和 GDT 没有不同，只是每个任务都有自己单独的 LDT，而且进行内存访问的时候只能使用自己的 LDT 来进行。因为 LDT 内只有和该任务自己相关的描述符存在，上述问题就得到了解决。</p><h2 id=处理器对支持多任务所做的设计>处理器对支持多任务所做的设计<a hidden class=anchor aria-hidden=true href=#处理器对支持多任务所做的设计>#</a></h2><p>为了应对多任务，我们引入了 TSS 和 LDT。那么为了便捷地找到 TSS 和 LDT 我们的处理器就增加了两个相应的寄存器：TR 和 LDTR。</p><p><img loading=lazy src=https://raw.githubusercontent.com/z1ggy-o/static_resources/main/img/TR-LDTR.png></p><p>TR 寄存器中我们存放当前任务 TSS 的地址，LDTR 中我们存放当前任务 LDT 的地址。段选择子中有一个 <code>TI</code> 位，指明我们需要使用 GDT 还是 LDT 进行寻址。</p><p>在实际的运行过程中，任务间的切换是相当频繁的。为了提高切换的速度，处理器会协助我们进行任务切换。具体的来说，只要我们给出想要切换的目标任务的 TSS，处理器会自动帮我们存储当前任务的信息，并且载入目标任务的信息。</p><h2 id=如何管理任务>如何管理任务<a hidden class=anchor aria-hidden=true href=#如何管理任务>#</a></h2><p>任务的切换由处理器来协助，但是什么时候进行切换，切换到哪一个任务是由操作系统说了算的。</p><p>为了进行任务调度，操作系统需要维护各个任务相关的信息，当前其中必须要有 TSS 和 LDT 的位置信息。所以，操作系统需要有一个内存区域来存放关于任务的信息，这个区域就叫做 Task Control Block (TCB)。</p><p>TCB 并不是处理器的工作要求，而是存粹的操作系统软件内容，所以，每个操作系统都可以设计自己管理 TCB 的方式，以及存放的信息。最最简单的模型就是，TCB 中只有 TSS 和 LDT 域，然后每个 TCB 用链表连接起来。当然，实际生活中的操作系统会用更加成熟高效的管理方式。</p><h2 id=如何进行任务切换>如何进行任务切换<a hidden class=anchor aria-hidden=true href=#如何进行任务切换>#</a></h2><p>任务切换有两种方式：</p><ul><li>协同式：即当前工作的任务主动放弃执行权；或者在其通过调用门请求操作系统系统服务的时候，由操作系统趁机把控制转换到另外的任务。</li><li>抢占式：一般情况下，是利用定时器中断，并在中断服务程序中实施任务切换。因为硬件中断信号总是会定时出现，任务切换总能够进行。</li></ul><p>使用控制转移指令，我们可以进行协同式的切换；利用中断，我们可以进行抢占式的中断。</p><p>这里追加一个信息。前一章中我们提到，可以使用调用门来进行特权转换。实际上，除了调用门之外，我们还有三类与中断相关的门，它们被存放在中断描述符表（IDT）中：</p><ul><li>中断门</li><li>陷阱门</li><li>任务门</li></ul><p>中断门和陷阱门在一般的中断处理中使用，指向的是处理函数的代码段选择子和段内偏移；而任务门则是用来进行任务切换的，存放着任务的 TSS 选择子。</p><h3 id=利用控制转移指令进行任务切换>利用控制转移指令进行任务切换<a hidden class=anchor aria-hidden=true href=#利用控制转移指令进行任务切换>#</a></h3><p>我们可以利用 <code>call</code> 和 <code>jmp</code> 指令并给出一个 GDT 中的 TSS 描述符。处理器转移过程中，发现对象是 TSS 描述符，就会相应的进行任务切换。</p><p>相似的，我们也可以利用 <code>call</code> 和 <code>jmp</code> 指令并给出一个任务门描述符。处理器判断出描述符指向任务门后，进行相应的任务切换。</p><h3 id=利用异常和中断进行切换>利用异常和中断进行切换<a hidden class=anchor aria-hidden=true href=#利用异常和中断进行切换>#</a></h3><p>如果异常或中断发生的时候，中断号指向的是中断描述符表中的任务门，处理器会进行相应的切换。</p><p>使用中断的时候有一个要点，即，不论是中断门，陷阱门，还是任务门，它们都是中断相关，所以最后都是用 <code>iret</code> 指令返回。前者是返回同一个任务的不同代码段，后者是返回到之前被中断暂停的任务。那么问题是，处理器如何知道自己该怎么做呢？</p><p>答案在 EFLAGS 寄存器的 <code>NT</code> 位上。NT 即 Nested，如果 <code>NT</code> 位被置为 1，则说明当前的任务是嵌套于其他任务，或者说，是从其他任务切换而来的。</p><p>处理器每次执行 <code>iret</code> 指令的时候都会检测当前 EFLAGS 寄存器的 <code>NT</code> 位。如果是 0 则说明是中断，直接返回即可；如果是 1 说明是任务切换，需要保存当前任务信息并载入之前的任务（之前任务的 TSS 位置被记录在当前任务的 TSS 中）。</p><p>这里也仅仅是简单地做一个介绍，实际的运行过程中还有相应的权限检测等内容。有需要的话请参照手册学习。</p><h2 id=总结>总结<a hidden class=anchor aria-hidden=true href=#总结>#</a></h2><ul><li>任务是一个运行中的程序的逻辑表达。也就是所谓的进程。</li><li>为了支持多任务，我们引入了 TSS 来存放一个任务的运行环境信息，以及 LDT 来进行任务间的空间隔离。</li><li>处理器在任务切换的时候会自动地帮助我们存储当前任务的信息，并载入新任务。但是什么时候进行任务切换，切换哪个任务，是由操作系统控制的。</li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://z1ggy-o.github.io/tags/computer-organization/>Computer Organization</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://z1ggy-o.github.io/>Gy's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>