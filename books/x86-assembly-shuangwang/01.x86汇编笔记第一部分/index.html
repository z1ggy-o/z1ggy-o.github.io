<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Note - x86 汇编语言（1）：计算机基础和实模式 | Gy's Blog</title>
<meta name=keywords content="Computer Organization"><meta name=description content="
最近读完了《x86 汇编语言：从实模式到保护模式》一书。感觉此书是了解 Intel 架构 CPU 运行方式的好材料。所以，我准备用四个篇章来写一份读书笔记，简略地介绍一下内存寻址方式，以及处理器对多任务的支持。笔记的内容意在指出书中的框架重点，作为一个快速复习和检索的工具，而非详实的内容。"><meta name=author content="Me"><link rel=canonical href=https://z1ggy-o.github.io/books/x86-assembly-shuangwang/01.x86%E6%B1%87%E7%BC%96%E7%AC%94%E8%AE%B0%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86/><link crossorigin=anonymous href=/assets/css/stylesheet.d6fcd20a4fb86efa4dfac8ec95da60244cc8871042183da1ef28e3a762ad79c8.css integrity="sha256-1vzSCk+4bvpN+sjsldpgJEzIhxBCGD2h7yjjp2Ktecg=" rel="preload stylesheet" as=style><link rel=icon href=https://z1ggy-o.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://z1ggy-o.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://z1ggy-o.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://z1ggy-o.github.io/apple-touch-icon.png><link rel=mask-icon href=https://z1ggy-o.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://z1ggy-o.github.io/books/x86-assembly-shuangwang/01.x86%E6%B1%87%E7%BC%96%E7%AC%94%E8%AE%B0%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://z1ggy-o.github.io/books/x86-assembly-shuangwang/01.x86%E6%B1%87%E7%BC%96%E7%AC%94%E8%AE%B0%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86/"><meta property="og:site_name" content="Gy's Blog"><meta property="og:title" content="Note - x86 汇编语言（1）：计算机基础和实模式"><meta property="og:description" content=" 最近读完了《x86 汇编语言：从实模式到保护模式》一书。感觉此书是了解 Intel 架构 CPU 运行方式的好材料。所以，我准备用四个篇章来写一份读书笔记，简略地介绍一下内存寻址方式，以及处理器对多任务的支持。笔记的内容意在指出书中的框架重点，作为一个快速复习和检索的工具，而非详实的内容。"><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="books"><meta property="article:published_time" content="2022-07-03T09:29:01+00:00"><meta property="article:modified_time" content="2024-12-28T10:32:24+00:00"><meta property="article:tag" content="Computer Organization"><meta name=twitter:card content="summary"><meta name=twitter:title content="Note - x86 汇编语言（1）：计算机基础和实模式"><meta name=twitter:description content="
最近读完了《x86 汇编语言：从实模式到保护模式》一书。感觉此书是了解 Intel 架构 CPU 运行方式的好材料。所以，我准备用四个篇章来写一份读书笔记，简略地介绍一下内存寻址方式，以及处理器对多任务的支持。笔记的内容意在指出书中的框架重点，作为一个快速复习和检索的工具，而非详实的内容。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Books","item":"https://z1ggy-o.github.io/books/"},{"@type":"ListItem","position":2,"name":"x86 汇编语言 - 王爽","item":"https://z1ggy-o.github.io/books/x86-assembly-shuangwang/"},{"@type":"ListItem","position":3,"name":"Note - x86 汇编语言（1）：计算机基础和实模式","item":"https://z1ggy-o.github.io/books/x86-assembly-shuangwang/01.x86%E6%B1%87%E7%BC%96%E7%AC%94%E8%AE%B0%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Note - x86 汇编语言（1）：计算机基础和实模式","name":"Note - x86 汇编语言（1）：计算机基础和实模式","description":" 最近读完了《x86 汇编语言：从实模式到保护模式》一书。感觉此书是了解 Intel 架构 CPU 运行方式的好材料。所以，我准备用四个篇章来写一份读书笔记，简略地介绍一下内存寻址方式，以及处理器对多任务的支持。笔记的内容意在指出书中的框架重点，作为一个快速复习和检索的工具，而非详实的内容。\n","keywords":["Computer Organization"],"articleBody":" 最近读完了《x86 汇编语言：从实模式到保护模式》一书。感觉此书是了解 Intel 架构 CPU 运行方式的好材料。所以，我准备用四个篇章来写一份读书笔记，简略地介绍一下内存寻址方式，以及处理器对多任务的支持。笔记的内容意在指出书中的框架重点，作为一个快速复习和检索的工具，而非详实的内容。\n本篇是该系列的第一个章节，专注于计算机的运行，8086 处理器，以及实模式。内容较为简单直接。其他章节如下：\n第一部分: 计算机基础和实模式 第二部分：保护模式下的分段寻址和权限 第三部分：多任务支持 第四部分：分页机制 计算机的基本结构和运行本质 我们当今使用的计算机结构为冯诺依曼结构。这个结构的特点就是以存储为中心。具体些说，这个结构中，我们将程序指令和数据以二进制的形式，不加区分地放在内存中。\n程序的编写者将提前编写好的程序载入内存，并告诉计算机将要执行的指令所在的位置，计算机便会到指定的地方找到指令并根据指令运行。抽象来说，计算机运行有 4 个步骤：\n取指 译码 执行 回写 可见，整个运行的过程主要就是两个内容：内存的读写，和计算。为了支持这个运作方式，硬件上，我们的计算机有五个重要的部分：\n运算器：进行计算 控制器：引导指令运行顺序 储存器：存放指令和数据 输入设备：和计算机进行沟通 输出设备：同上 虽然我们每天接触的计算机看似非凡超能，但是它其实是一个十分单纯的机器。从通电的一刻开始，计算机就是在不断地重复我们上面讲的四个运行步骤。\n以计算机的启动过程为例 我们使用的计算机，在每次通电的时候，都会从一个提前指定好的内存地址开始，进行取指和运算。\n那个起始位置，存放的就是 BIOS 的第一行指令。BIOS 在完成自己的工作后，其最后的一部分指令就是把其他的程序读取到指定的内存位置，并让计算机从那个位置继续运行。\n一般来说，BIOS 的最后一部分指令会将启动磁盘的第一个扇区读取到内存中，并跳转执行。也是因为这个原因，我们把启动磁盘的第一个扇区叫做主引导扇区。\n因为我们可以方便地向磁盘写入数据，主引导扇区是我们最先能接触到的代码区域。它的容量不大，其中的指令一般是继续从磁盘中读取其他程序并运行。例如，它可以载入 bootloader 并最终引导操作系统。\n8086 的基本结构 8086 是一枚极其成功的处理器，它是应用最广泛个人计算机行业的基础，x86 的 86 就是说这个 86。它极大地影响了 Intel 接下来的处理器功能设计。可以说，更加新型的 Intel 处理器都是在 8086 的底子上进行功能的完善和添加。\n8086 是一枚 16 位的处理器。它的寄存器，以及内外部的数据线的位宽都是 16 位，不过外部地址线是 20 位的，这给了它更强的寻址能力，也引出了分段模型。\n8086 一共有三种不同的寻址模式 (即数据的读取和存放方式)：\n寄存器寻址 立即寻址 内存寻址 从寻址模式上可以看出，除了内存之外，寄存器也是一个相当重要部件。而对于这个章节的内容来说，最重要的寄存器就是指令寄存器 IP，以及多个段寄存器。\n指令寄存器之所以重要，是因为处理器根据它的内容来进行取指。而段寄存器之所以重要，是因为我们需要借助它们来进行内存寻址。\n8086 的分段模型 上面我们提到除了外部地址线是 20 位的，8086 的其他部件都是 16 位。之所以提出内存的分段访问模型，就是为了能够实现 20 位的寻址能力。\n其方式为：段寄存器内的值左移 4 位，加上 16 位段内偏移。如此一来，便拼凑出了 20 位的地址。处理器会根据此地址直接和内存沟通，实现数据的读写。\n段寄存器内的值叫做段基地址。通过修改段寄存器内的段基地址，我们就可以在逻辑上将内存分段，每个段最大有 16 位的寻址能力。分段不仅使得我们有了更强的寻址能力，也让程序载入重定位变得更加容易：程序编写的时候使用相对某个段的相对地址，使得载入位置变得随意。\n具体的寻址指令以及处理器的其他信息就不在此叙述，手册才是它们的归宿。\nIntel 处理器的实模式 实模式，又叫实地址模式。它其实就是 8086 的运行模式。这个“实”字其实有两个含义：\n第一个含义是，我们在指令中给出的内存地址，即为处理器使用的地址。我们直接向段寄存器赋值段基地址，然后与段内偏移结合，获得内存物理地址。\n实模式的另一个含义，其实也是上面提到的 8086 的特点，就是它无条件的相信我们给出的指令。在实模式下，所有的段都可以随意读、写，其中存放的内容也可以被随意执行。\n接下来我们要讲的保护模式，就是对针对各个段的读写，以及执行加以权限控制的模式。\n总结 我们现在使用的冯诺依曼结构计算机，将数据和指令无差别地以二进制存放在存储装置中的。 计算机很单纯。它就是在不断地读取指令，运行指令，然后将运行结果存放。 8086 处理器通过段寄存器实现了分段模型进行内存访问，作为一个 16 位处理器，提供了 20 位的寻址能力。 8086 很单纯。它允许我们任意地读、写、执行内存中的内容。 ","wordCount":"1890","inLanguage":"en","datePublished":"2022-07-03T09:29:01Z","dateModified":"2024-12-28T10:32:24.596832969Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://z1ggy-o.github.io/books/x86-assembly-shuangwang/01.x86%E6%B1%87%E7%BC%96%E7%AC%94%E8%AE%B0%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86/"},"publisher":{"@type":"Organization","name":"Gy's Blog","logo":{"@type":"ImageObject","url":"https://z1ggy-o.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://z1ggy-o.github.io/ accesskey=h title="Gy's Blog (Alt + H)">Gy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://z1ggy-o.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://z1ggy-o.github.io/weekly/ title=Logs><span>Logs</span></a></li><li><a href=https://z1ggy-o.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://z1ggy-o.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://z1ggy-o.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://z1ggy-o.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://z1ggy-o.github.io/books/>Books</a>&nbsp;»&nbsp;<a href=https://z1ggy-o.github.io/books/x86-assembly-shuangwang/>x86 汇编语言 - 王爽</a></div><h1 class="post-title entry-hint-parent">Note - x86 汇编语言（1）：计算机基础和实模式</h1><div class=post-meta><span title='2022-07-03 09:29:01 +0000 UTC'>July 3, 2022</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Me</div></header><div class=post-content><hr><p>最近读完了《x86 汇编语言：从实模式到保护模式》一书。感觉此书是了解 Intel 架构 CPU 运行方式的好材料。所以，我准备用四个篇章来写一份读书笔记，简略地介绍一下内存寻址方式，以及处理器对多任务的支持。笔记的内容意在指出书中的框架重点，作为一个快速复习和检索的工具，而非详实的内容。</p><p>本篇是该系列的第一个章节，专注于计算机的运行，8086 处理器，以及实模式。内容较为简单直接。其他章节如下：</p><ul><li><a href=../01.x86%E6%B1%87%E7%BC%96%E7%AC%94%E8%AE%B0%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86/>第一部分: 计算机基础和实模式</a></li><li><a href=02.x86%E6%B1%87%E7%BC%96%E7%AC%94%E8%AE%B0%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86/>第二部分：保护模式下的分段寻址和权限</a></li><li><a href=03.x86%E6%B1%87%E7%BC%96%E7%AC%94%E8%AE%B0%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86/>第三部分：多任务支持</a></li><li><a href=04.x86%E6%B1%87%E7%BC%96%E7%AC%94%E8%AE%B0%E7%AC%AC%E5%9B%9B%E9%83%A8%E5%88%86/>第四部分：分页机制</a></li></ul><h2 id=计算机的基本结构和运行本质>计算机的基本结构和运行本质<a hidden class=anchor aria-hidden=true href=#计算机的基本结构和运行本质>#</a></h2><p>我们当今使用的计算机结构为冯诺依曼结构。这个结构的特点就是以存储为中心。具体些说，这个结构中，我们将程序指令和数据以二进制的形式，不加区分地放在内存中。</p><p>程序的编写者将提前编写好的程序载入内存，并告诉计算机将要执行的指令所在的位置，计算机便会到指定的地方找到指令并根据指令运行。抽象来说，计算机运行有 4 个步骤：</p><ol><li>取指</li><li>译码</li><li>执行</li><li>回写</li></ol><p>可见，整个运行的过程主要就是两个内容：内存的读写，和计算。为了支持这个运作方式，硬件上，我们的计算机有五个重要的部分：</p><ul><li>运算器：进行计算</li><li>控制器：引导指令运行顺序</li><li>储存器：存放指令和数据</li><li>输入设备：和计算机进行沟通</li><li>输出设备：同上</li></ul><p>虽然我们每天接触的计算机看似非凡超能，但是它其实是一个十分单纯的机器。从通电的一刻开始，计算机就是在不断地重复我们上面讲的四个运行步骤。</p><h2 id=以计算机的启动过程为例>以计算机的启动过程为例<a hidden class=anchor aria-hidden=true href=#以计算机的启动过程为例>#</a></h2><p>我们使用的计算机，在每次通电的时候，都会从一个提前指定好的内存地址开始，进行取指和运算。</p><p>那个起始位置，存放的就是 <a href=https://en.wikipedia.org/wiki/BIOS>BIOS</a> 的第一行指令。BIOS 在完成自己的工作后，其最后的一部分指令就是把其他的程序读取到指定的内存位置，并让计算机从那个位置继续运行。</p><p>一般来说，BIOS 的最后一部分指令会将启动磁盘的第一个扇区读取到内存中，并跳转执行。也是因为这个原因，我们把启动磁盘的第一个扇区叫做主引导扇区。</p><p>因为我们可以方便地向磁盘写入数据，主引导扇区是我们最先能接触到的代码区域。它的容量不大，其中的指令一般是继续从磁盘中读取其他程序并运行。例如，它可以载入 bootloader 并最终引导操作系统。</p><h2 id=8086-的基本结构>8086 的基本结构<a hidden class=anchor aria-hidden=true href=#8086-的基本结构>#</a></h2><p><img loading=lazy src=https://raw.githubusercontent.com/z1ggy-o/static_resources/main/img/8086-architecture.png></p><p>8086 是一枚极其成功的处理器，它是应用最广泛个人计算机行业的基础，x86 的 86 就是说这个 86。它极大地影响了 Intel 接下来的处理器功能设计。可以说，更加新型的 Intel 处理器都是在 8086 的底子上进行功能的完善和添加。</p><p>8086 是一枚 16 位的处理器。它的寄存器，以及内外部的数据线的位宽都是 16 位，不过外部地址线是 20 位的，这给了它更强的寻址能力，也引出了分段模型。</p><p>8086 一共有三种不同的寻址模式 (即数据的读取和存放方式)：</p><ul><li>寄存器寻址</li><li>立即寻址</li><li>内存寻址</li></ul><p>从寻址模式上可以看出，除了内存之外，寄存器也是一个相当重要部件。而对于这个章节的内容来说，最重要的寄存器就是指令寄存器 IP，以及多个段寄存器。</p><p>指令寄存器之所以重要，是因为处理器根据它的内容来进行取指。而段寄存器之所以重要，是因为我们需要借助它们来进行内存寻址。</p><h2 id=8086-的分段模型>8086 的分段模型<a hidden class=anchor aria-hidden=true href=#8086-的分段模型>#</a></h2><p>上面我们提到除了外部地址线是 20 位的，8086 的其他部件都是 16 位。之所以提出内存的分段访问模型，就是为了能够实现 20 位的寻址能力。</p><p>其方式为：段寄存器内的值左移 4 位，加上 16 位段内偏移。如此一来，便拼凑出了 20 位的地址。处理器会根据此地址直接和内存沟通，实现数据的读写。</p><p>段寄存器内的值叫做<em>段基地址</em>。通过修改段寄存器内的段基地址，我们就可以在逻辑上将内存分段，每个段最大有 16 位的寻址能力。分段不仅使得我们有了更强的寻址能力，也让程序载入重定位变得更加容易：程序编写的时候使用相对某个段的相对地址，使得载入位置变得随意。</p><p>具体的寻址指令以及处理器的其他信息就不在此叙述，手册才是它们的归宿。</p><h2 id=intel-处理器的实模式>Intel 处理器的实模式<a hidden class=anchor aria-hidden=true href=#intel-处理器的实模式>#</a></h2><p>实模式，又叫实地址模式。它其实就是 8086 的运行模式。这个“实”字其实有两个含义：</p><p>第一个含义是，我们在指令中给出的内存地址，即为处理器使用的地址。我们直接向段寄存器赋值段基地址，然后与段内偏移结合，获得内存物理地址。</p><p>实模式的另一个含义，其实也是上面提到的 8086 的特点，就是它无条件的相信我们给出的指令。在实模式下，所有的段都可以随意读、写，其中存放的内容也可以被随意执行。</p><p>接下来我们要讲的保护模式，就是对针对各个段的读写，以及执行加以权限控制的模式。</p><h2 id=总结>总结<a hidden class=anchor aria-hidden=true href=#总结>#</a></h2><ul><li>我们现在使用的冯诺依曼结构计算机，将数据和指令无差别地以二进制存放在存储装置中的。</li><li>计算机很单纯。它就是在不断地读取指令，运行指令，然后将运行结果存放。</li><li>8086 处理器通过段寄存器实现了分段模型进行内存访问，作为一个 16 位处理器，提供了 20 位的寻址能力。</li><li>8086 很单纯。它允许我们任意地读、写、执行内存中的内容。</li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://z1ggy-o.github.io/tags/computer-organization/>Computer Organization</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://z1ggy-o.github.io/>Gy's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>