<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>LevelDB 源码分析笔记 | Gy's Blog</title>
<meta name=keywords content="DBMS,LSM-Tree"><meta name=description content="最近一周花了些时间阅读了 LevelDB 的代码，了解一下 LSM-Tree 的具体实现。在阅读的过程中简略的记录了一些笔记，放在了我的 Github repo 里。笔记是用蹩脚英语写的，也没有做任何的插图，建议配合此分析文档一起食用。"><meta name=author content="Gy"><link rel=canonical href=https://z1ggy-o.github.io/posts/leveldb-analysis/><link crossorigin=anonymous href=/assets/css/stylesheet.d6fcd20a4fb86efa4dfac8ec95da60244cc8871042183da1ef28e3a762ad79c8.css integrity="sha256-1vzSCk+4bvpN+sjsldpgJEzIhxBCGD2h7yjjp2Ktecg=" rel="preload stylesheet" as=style><link rel=icon href=https://z1ggy-o.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://z1ggy-o.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://z1ggy-o.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://z1ggy-o.github.io/apple-touch-icon.png><link rel=mask-icon href=https://z1ggy-o.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://z1ggy-o.github.io/posts/leveldb-analysis/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://z1ggy-o.github.io/posts/leveldb-analysis/"><meta property="og:site_name" content="Gy's Blog"><meta property="og:title" content="LevelDB 源码分析笔记"><meta property="og:description" content="最近一周花了些时间阅读了 LevelDB 的代码，了解一下 LSM-Tree 的具体实现。在阅读的过程中简略的记录了一些笔记，放在了我的 Github repo 里。笔记是用蹩脚英语写的，也没有做任何的插图，建议配合此分析文档一起食用。"><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-08-22T13:30:19+00:00"><meta property="article:modified_time" content="2024-12-28T17:15:56+08:00"><meta property="article:tag" content="DBMS"><meta property="article:tag" content="LSM-Tree"><meta name=twitter:card content="summary"><meta name=twitter:title content="LevelDB 源码分析笔记"><meta name=twitter:description content="最近一周花了些时间阅读了 LevelDB 的代码，了解一下 LSM-Tree 的具体实现。在阅读的过程中简略的记录了一些笔记，放在了我的 Github repo 里。笔记是用蹩脚英语写的，也没有做任何的插图，建议配合此分析文档一起食用。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"","item":"https://z1ggy-o.github.io/posts/"},{"@type":"ListItem","position":2,"name":"LevelDB 源码分析笔记","item":"https://z1ggy-o.github.io/posts/leveldb-analysis/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"LevelDB 源码分析笔记","name":"LevelDB 源码分析笔记","description":"最近一周花了些时间阅读了 LevelDB 的代码，了解一下 LSM-Tree 的具体实现。在阅读的过程中简略的记录了一些笔记，放在了我的 Github repo 里。笔记是用蹩脚英语写的，也没有做任何的插图，建议配合此分析文档一起食用。\n","keywords":["DBMS","LSM-Tree"],"articleBody":"最近一周花了些时间阅读了 LevelDB 的代码，了解一下 LSM-Tree 的具体实现。在阅读的过程中简略的记录了一些笔记，放在了我的 Github repo 里。笔记是用蹩脚英语写的，也没有做任何的插图，建议配合此分析文档一起食用。\nLSM-Tree 虽然很早被提出，但是在 LevelDB 这个开源实现被公开之后才引发了比较广泛的研究。毕竟，拿来的是最舒服的，虽然概念简单，但是细节很多。有些时候代码比语言更清晰，所以，我的笔记里主要还是将概念和具体的代码做了关联，细节还是要到代码里去扣。\n在这里，主要想要用简单的语言介绍一下 LevelDB 的主要框架。方便想要花五分钟大致了解一下 LevelDB 的朋友。\nLevelDB，一个 LSM-Tree 的开源实现 LSM-Tree 的特点在于其对存储内容的排序和 append-only 的写入模式。此工作模式主要有两个优点：\n极佳的写入性能。不需要做 read-modify-write。 便利的并行控制。写入的内容不会再被修改，可以放心的做并行读取。 但是物理世界里，一切都是有利弊的。LSM-Tree 的读取性能并不优秀。因为有过期数据的存在，读取过程中可能会需要读取多个文件，会有 read-amplification 的问题。过期数据也会浪费存储空间。\n插一句，对 write-amplification (WA) 问题，LSM-Tree 和 B-Tree 两者都有，但是具体的情景是不一样的。LSM-Tree 的 WA 来源于 compaction 过程，需要将已有的数据重新写入。而 B-Tree 的 WA 来源于其固定 page 大小的写入单位。就算一个 page 内只有一个 byte 被修改了，整个 page 也需要写回。\n接下来主要针对 LevelDB 的写入和读取两个部分的设计部件作一下简介。\n写入：Memtable 和 SSTable LevelDB 只允许写入请求（即插入，更新，删除）发生在内存内的 memtable 中。Memtable 是实现于 skiplist 数据结构，在提供良好插入性能的情况下也保持 item 有序。\n当一个 memtable 达到预定的大小之后，memtable 会被写入到磁盘中，成为一个 SSTable 文件。因为在 memtable 写出的时候就不能再接收写请求了，LevelDB 使用了 double-buffer 的策略，另起一个 memtable 接收写请求。\n为了避免故障带来的数据损失，LevelDB 也使用了 WAL 的方式来记录请求内容。不过因为 LevelDB 只是一个简单的 KV 引擎，log 几乎就是请求内容的复制记录。而且，在 memtable 被持久化之后，对应的 log 文件就可以抛弃了。\n总的来说，log-structuring 本身已经为写入带来了极大的便利，所以这个部分的特别设计并不多。\n读取：SSTable 结构和 MVCC 因为 LSM-Tree 的读取性能并不好，LevelDB 为了提升读取性能还是花了一番力气的。\nSSTable 结构 Memtable 只是一个 skiplist，其中一个 node 代表一个写入请求指令的内容。如何将这些内容进行安排，决定了读取过程的效率。LevelDB 主要做了一下几个设计：\nSSTable 文件按新旧序号排列。更新的文件中自然存放着更新的数据。 SSTable 文件的底部设计了一个 footer 部分，可以帮助快速识别目标 key 所在的位置，减少读取量。 SSTable 内部嵌入 bloom filter，进一步减少不必要的读取。 更加具体的内容请参照笔记和源码。\nMVCC LevelDB 是支持针对数据进行 snapshot 读取的。它的实现方式倒也简单直接。在 DB 的每一条记录中，都包含一个单调递增的 sequence number。当要进行 snapshot 读取的时候，LevelDB 会告诉读请求当时的最新 sequence number。如此一来通过比较，就可以避免读到更新的数值了。这个设计的好处在于，读不会阻塞写。\nLevelDB 抽象了一个 Version 对象，记录了一个版本的文件。每当有 sstable 生成或删除的时候，就形成一个新的版本。如果有请求在使用某个版本的文件，那么即使这个文件已经过期，也会等到所有的使用都完毕之后才会被清理。\nCache 除此之外，LevelDB 也实现了一个比较标准的 LRUCache。该 cache 主要缓存打开的文件句柄，以及读取的数据块。\n用户也可以选择不使用这个 cache。比如，如果做大范围的 range read 的话，用 cache 的意义不大。\n清理，Compaction 因为 append-only 的写入方式会让 DB 中存有过期的数据，我们需要定期的对数据进行清理，释放不需要的存储空间。\nLevelDB 使用 leveling compaction 的方式来做这个清理。具体来说，sstable 文件被按层级安排在了一起，低层的数据存放量少，数据更新；高层的数据存放量更大，但是数据旧。\ncompaction 是在两个相邻层级中的文件中进行的。先是在上层中找到一个对象文件，然后根据其 key 的范围，在下一层中找到有 key 重叠的文件。最后，因为所有的记录都是排好序的，利用 k-way merge 的方式就可以将过期的数据筛除。有效的数据被写入到新的 sstable 文件中，放入到下层里。这个过程可能在各个层级递归进行。\n寻找 compaction 对象文件的过程略微复杂，有兴趣可以参照笔记和源码学习。\n因为 compaction 是一个比较昂贵的操作，LevelDB 定义了三个条件来决定是否需要做 compaction：\nLevel 0 （最低层）的文件数量超过了限制； 其他层的数据量超过了限制； 一个文件的无效读取次数超过了限制。 结语 LevelDB 的代码量并不算很大，但是确实设计的很好。早就听说这是一个学习 C++ 的好材料，如今一读，确实如此。特别是对于我这种常年打 C 补丁的选手，LevelDB 实打实的给上了一节 OOP 的实践课。也推荐给所有想了解 LSM-Tree，学习 C++ OOP 范式的同学阅读。\n","wordCount":"1962","inLanguage":"en","datePublished":"2022-08-22T13:30:19Z","dateModified":"2024-12-28T17:15:56+08:00","author":{"@type":"Person","name":"Gy"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://z1ggy-o.github.io/posts/leveldb-analysis/"},"publisher":{"@type":"Organization","name":"Gy's Blog","logo":{"@type":"ImageObject","url":"https://z1ggy-o.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://z1ggy-o.github.io/ accesskey=h title="Gy's Blog (Alt + H)">Gy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://z1ggy-o.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://z1ggy-o.github.io/weekly/ title=Logs><span>Logs</span></a></li><li><a href=https://z1ggy-o.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://z1ggy-o.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://z1ggy-o.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://z1ggy-o.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://z1ggy-o.github.io/posts/></a></div><h1 class="post-title entry-hint-parent">LevelDB 源码分析笔记</h1><div class=post-meta><span title='2022-08-22 13:30:19 +0000 UTC'>August 22, 2022</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Gy</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#leveldb%e4%b8%80%e4%b8%aa-lsm-tree-%e7%9a%84%e5%bc%80%e6%ba%90%e5%ae%9e%e7%8e%b0 aria-label="LevelDB，一个 LSM-Tree 的开源实现">LevelDB，一个 LSM-Tree 的开源实现</a></li><li><a href=#%e5%86%99%e5%85%a5memtable-%e5%92%8c-sstable aria-label="写入：Memtable 和 SSTable">写入：Memtable 和 SSTable</a></li><li><a href=#%e8%af%bb%e5%8f%96sstable-%e7%bb%93%e6%9e%84%e5%92%8c-mvcc aria-label="读取：SSTable 结构和 MVCC">读取：SSTable 结构和 MVCC</a><ul><li><a href=#sstable-%e7%bb%93%e6%9e%84 aria-label="SSTable 结构">SSTable 结构</a></li><li><a href=#mvcc aria-label=MVCC>MVCC</a></li><li><a href=#cache aria-label=Cache>Cache</a></li></ul></li><li><a href=#%e6%b8%85%e7%90%86compaction aria-label=清理，Compaction>清理，Compaction</a></li><li><a href=#%e7%bb%93%e8%af%ad aria-label=结语>结语</a></li></ul></div></details></div><div class=post-content><p>最近一周花了些时间阅读了 LevelDB 的代码，了解一下 LSM-Tree 的具体实现。在阅读的过程中简略的记录了一些笔记，放在了我的 <a href=https://github.com/z1ggy-o/LevelDB-Notes/tree/main/Notes>Github repo</a> 里。笔记是用蹩脚英语写的，也没有做任何的插图，建议配合<a href=https://leveldb-handbook.readthedocs.io/zh/latest/basic.html>此分析文档</a>一起食用。</p><p>LSM-Tree 虽然很早被提出，但是在 LevelDB 这个开源实现被公开之后才引发了比较广泛的研究。毕竟，<del>拿来的是最舒服的</del>，虽然概念简单，但是细节很多。有些时候代码比语言更清晰，所以，我的笔记里主要还是将概念和具体的代码做了关联，细节还是要到代码里去扣。</p><p>在这里，主要想要用简单的语言介绍一下 LevelDB 的主要框架。方便想要花五分钟大致了解一下 LevelDB 的朋友。</p><h2 id=leveldb一个-lsm-tree-的开源实现>LevelDB，一个 LSM-Tree 的开源实现<a hidden class=anchor aria-hidden=true href=#leveldb一个-lsm-tree-的开源实现>#</a></h2><p><a href=https://en.wikipedia.org/wiki/Log-structured_merge-tree>LSM-Tree</a> 的特点在于其对存储内容的排序和 append-only 的写入模式。此工作模式主要有两个优点：</p><ul><li>极佳的写入性能。不需要做 read-modify-write。</li><li>便利的并行控制。写入的内容不会再被修改，可以放心的做并行读取。</li></ul><p>但是物理世界里，一切都是有利弊的。LSM-Tree 的读取性能并不优秀。因为有过期数据的存在，读取过程中可能会需要读取多个文件，会有 read-amplification 的问题。过期数据也会浪费存储空间。</p><p>插一句，对 write-amplification (WA) 问题，LSM-Tree 和 B-Tree 两者都有，但是具体的情景是不一样的。LSM-Tree 的 WA 来源于 compaction 过程，需要将已有的数据重新写入。而 B-Tree 的 WA 来源于其固定 page 大小的写入单位。就算一个 page 内只有一个 byte 被修改了，整个 page 也需要写回。</p><p>接下来主要针对 LevelDB 的写入和读取两个部分的设计部件作一下简介。</p><h2 id=写入memtable-和-sstable>写入：Memtable 和 SSTable<a hidden class=anchor aria-hidden=true href=#写入memtable-和-sstable>#</a></h2><p>LevelDB 只允许写入请求（即插入，更新，删除）发生在内存内的 memtable 中。Memtable 是实现于 skiplist 数据结构，在提供良好插入性能的情况下也保持 item 有序。</p><p>当一个 memtable 达到预定的大小之后，memtable 会被写入到磁盘中，成为一个 SSTable 文件。因为在 memtable 写出的时候就不能再接收写请求了，LevelDB 使用了 double-buffer 的策略，另起一个 memtable 接收写请求。</p><p>为了避免故障带来的数据损失，LevelDB 也使用了 WAL 的方式来记录请求内容。不过因为 LevelDB 只是一个简单的 KV 引擎，log 几乎就是请求内容的复制记录。而且，在 memtable 被持久化之后，对应的 log 文件就可以抛弃了。</p><p>总的来说，log-structuring 本身已经为写入带来了极大的便利，所以这个部分的特别设计并不多。</p><h2 id=读取sstable-结构和-mvcc>读取：SSTable 结构和 MVCC<a hidden class=anchor aria-hidden=true href=#读取sstable-结构和-mvcc>#</a></h2><p>因为 LSM-Tree 的读取性能并不好，LevelDB 为了提升读取性能还是花了一番力气的。</p><h3 id=sstable-结构>SSTable 结构<a hidden class=anchor aria-hidden=true href=#sstable-结构>#</a></h3><p>Memtable 只是一个 skiplist，其中一个 node 代表一个写入请求指令的内容。如何将这些内容进行安排，决定了读取过程的效率。LevelDB 主要做了一下几个设计：</p><ul><li>SSTable 文件按新旧序号排列。更新的文件中自然存放着更新的数据。</li><li>SSTable 文件的底部设计了一个 footer 部分，可以帮助快速识别目标 key 所在的位置，减少读取量。</li><li>SSTable 内部嵌入 bloom filter，进一步减少不必要的读取。</li></ul><p>更加具体的内容请参照笔记和源码。</p><h3 id=mvcc>MVCC<a hidden class=anchor aria-hidden=true href=#mvcc>#</a></h3><p>LevelDB 是支持针对数据进行 snapshot 读取的。它的实现方式倒也简单直接。在 DB 的每一条记录中，都包含一个单调递增的 sequence number。当要进行 snapshot 读取的时候，LevelDB 会告诉读请求当时的最新 sequence number。如此一来通过比较，就可以避免读到更新的数值了。这个设计的好处在于，读不会阻塞写。</p><p>LevelDB 抽象了一个 <code>Version</code> 对象，记录了一个版本的文件。每当有 sstable 生成或删除的时候，就形成一个新的版本。如果有请求在使用某个版本的文件，那么即使这个文件已经过期，也会等到所有的使用都完毕之后才会被清理。</p><h3 id=cache>Cache<a hidden class=anchor aria-hidden=true href=#cache>#</a></h3><p>除此之外，LevelDB 也实现了一个比较标准的 LRUCache。该 cache 主要缓存打开的文件句柄，以及读取的数据块。</p><p>用户也可以选择不使用这个 cache。比如，如果做大范围的 range read 的话，用 cache 的意义不大。</p><h2 id=清理compaction>清理，Compaction<a hidden class=anchor aria-hidden=true href=#清理compaction>#</a></h2><p>因为 append-only 的写入方式会让 DB 中存有过期的数据，我们需要定期的对数据进行清理，释放不需要的存储空间。</p><p>LevelDB 使用 leveling compaction 的方式来做这个清理。具体来说，sstable 文件被按层级安排在了一起，低层的数据存放量少，数据更新；高层的数据存放量更大，但是数据旧。</p><p>compaction 是在两个相邻层级中的文件中进行的。先是在上层中找到一个对象文件，然后根据其 key 的范围，在下一层中找到有 key 重叠的文件。最后，因为所有的记录都是排好序的，利用 k-way merge 的方式就可以将过期的数据筛除。有效的数据被写入到新的 sstable 文件中，放入到下层里。这个过程可能在各个层级递归进行。</p><p>寻找 compaction 对象文件的过程略微复杂，有兴趣可以参照笔记和源码学习。</p><p>因为 compaction 是一个比较昂贵的操作，LevelDB 定义了三个条件来决定是否需要做 compaction：</p><ul><li>Level 0 （最低层）的文件数量超过了限制；</li><li>其他层的数据量超过了限制；</li><li>一个文件的无效读取次数超过了限制。</li></ul><h2 id=结语>结语<a hidden class=anchor aria-hidden=true href=#结语>#</a></h2><p>LevelDB 的代码量并不算很大，但是确实设计的很好。早就听说这是一个学习 C++ 的好材料，如今一读，确实如此。特别是对于我这种常年打 C 补丁的选手，LevelDB 实打实的给上了一节 OOP 的实践课。也推荐给所有想了解 LSM-Tree，学习 C++ OOP 范式的同学阅读。</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://z1ggy-o.github.io/tags/dbms/>DBMS</a></li><li><a href=https://z1ggy-o.github.io/tags/lsm-tree/>LSM-Tree</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://z1ggy-o.github.io/>Gy's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>