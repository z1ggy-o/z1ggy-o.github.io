<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>2PC v.s. 3PC: 一句话的总结 | Gy's Blog</title>
<meta name=keywords content="distributed-systems"><meta name=description content="最近在准备面试的过程中看到有这样一个问题，就是让比较一下 2PC 和 3PC。在网上找了一些文章来读，感觉都没有十分简洁地说明两者之间最基本的区别点。所以，在这里写一篇小文，表达一下自己对 2PC，3PC 最核心区别的理解。
最重要的最先说，在我看来两者的核心区别在于：参与者间是否对 transaction commit/abort 建立了共识。3PC 的参与者之间对 commit 的成立是具有共识的，2PC 则没有。
3PC 相比 2PC 带来了什么？
大家都知道，3PC 相比于 2PC 来说多了两个东西：

增加了 time out
commit phase 被分割为了 prepare commit 和 do commit 两个部分

增加一个 prepare commit phase 带来了什么呢？是集群对 commit 这一决定的共识。
在 2PC 协议中，协调者单方面向参与者发送一次 commit 消息。这个消息有两个含义：

让参与者进行 commit
所有参与者都认可此 commit

但需要注意的是，对于一个 transaction，是 commit 还是 abort 这个决定本身只有协调者知道。一旦协调者故障，这部分信息就消失了。所以我们说 2PC 的协调者是单点故障点。
3PC 协议中，prepare commit 消息让一个 transaction 该 commit 还是 abort 这个决定本身被传导到了所有参与者处。如此一来，如果协调者故障，参与者们可以根据 prepare commit 的情况继续工作。"><meta name=author content="Me"><link rel=canonical href=https://z1ggy-o.github.io/posts/2pc-vs-3pc/><link crossorigin=anonymous href=/assets/css/stylesheet.d6fcd20a4fb86efa4dfac8ec95da60244cc8871042183da1ef28e3a762ad79c8.css integrity="sha256-1vzSCk+4bvpN+sjsldpgJEzIhxBCGD2h7yjjp2Ktecg=" rel="preload stylesheet" as=style><link rel=icon href=https://z1ggy-o.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://z1ggy-o.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://z1ggy-o.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://z1ggy-o.github.io/apple-touch-icon.png><link rel=mask-icon href=https://z1ggy-o.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://z1ggy-o.github.io/posts/2pc-vs-3pc/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css integrity=sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js integrity=sha384-g7c+Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI+sEnkvrMWph2EDg4 crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js integrity=sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC+Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa crossorigin=anonymous onload=renderMathInElement(document.body)></script><meta property="og:url" content="https://z1ggy-o.github.io/posts/2pc-vs-3pc/"><meta property="og:site_name" content="Gy's Blog"><meta property="og:title" content="2PC v.s. 3PC: 一句话的总结"><meta property="og:description" content="最近在准备面试的过程中看到有这样一个问题，就是让比较一下 2PC 和 3PC。在网上找了一些文章来读，感觉都没有十分简洁地说明两者之间最基本的区别点。所以，在这里写一篇小文，表达一下自己对 2PC，3PC 最核心区别的理解。
最重要的最先说，在我看来两者的核心区别在于：参与者间是否对 transaction commit/abort 建立了共识。3PC 的参与者之间对 commit 的成立是具有共识的，2PC 则没有。
3PC 相比 2PC 带来了什么？ 大家都知道，3PC 相比于 2PC 来说多了两个东西：
增加了 time out commit phase 被分割为了 prepare commit 和 do commit 两个部分 增加一个 prepare commit phase 带来了什么呢？是集群对 commit 这一决定的共识。
在 2PC 协议中，协调者单方面向参与者发送一次 commit 消息。这个消息有两个含义：
让参与者进行 commit 所有参与者都认可此 commit 但需要注意的是，对于一个 transaction，是 commit 还是 abort 这个决定本身只有协调者知道。一旦协调者故障，这部分信息就消失了。所以我们说 2PC 的协调者是单点故障点。
3PC 协议中，prepare commit 消息让一个 transaction 该 commit 还是 abort 这个决定本身被传导到了所有参与者处。如此一来，如果协调者故障，参与者们可以根据 prepare commit 的情况继续工作。"><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:modified_time" content="2024-12-28T14:09:27+08:00"><meta property="article:tag" content="Distributed-Systems"><meta name=twitter:card content="summary"><meta name=twitter:title content="2PC v.s. 3PC: 一句话的总结"><meta name=twitter:description content="最近在准备面试的过程中看到有这样一个问题，就是让比较一下 2PC 和 3PC。在网上找了一些文章来读，感觉都没有十分简洁地说明两者之间最基本的区别点。所以，在这里写一篇小文，表达一下自己对 2PC，3PC 最核心区别的理解。
最重要的最先说，在我看来两者的核心区别在于：参与者间是否对 transaction commit/abort 建立了共识。3PC 的参与者之间对 commit 的成立是具有共识的，2PC 则没有。
3PC 相比 2PC 带来了什么？
大家都知道，3PC 相比于 2PC 来说多了两个东西：

增加了 time out
commit phase 被分割为了 prepare commit 和 do commit 两个部分

增加一个 prepare commit phase 带来了什么呢？是集群对 commit 这一决定的共识。
在 2PC 协议中，协调者单方面向参与者发送一次 commit 消息。这个消息有两个含义：

让参与者进行 commit
所有参与者都认可此 commit

但需要注意的是，对于一个 transaction，是 commit 还是 abort 这个决定本身只有协调者知道。一旦协调者故障，这部分信息就消失了。所以我们说 2PC 的协调者是单点故障点。
3PC 协议中，prepare commit 消息让一个 transaction 该 commit 还是 abort 这个决定本身被传导到了所有参与者处。如此一来，如果协调者故障，参与者们可以根据 prepare commit 的情况继续工作。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"","item":"https://z1ggy-o.github.io/posts/"},{"@type":"ListItem","position":2,"name":"2PC v.s. 3PC: 一句话的总结","item":"https://z1ggy-o.github.io/posts/2pc-vs-3pc/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"2PC v.s. 3PC: 一句话的总结","name":"2PC v.s. 3PC: 一句话的总结","description":"最近在准备面试的过程中看到有这样一个问题，就是让比较一下 2PC 和 3PC。在网上找了一些文章来读，感觉都没有十分简洁地说明两者之间最基本的区别点。所以，在这里写一篇小文，表达一下自己对 2PC，3PC 最核心区别的理解。\n最重要的最先说，在我看来两者的核心区别在于：参与者间是否对 transaction commit/abort 建立了共识。3PC 的参与者之间对 commit 的成立是具有共识的，2PC 则没有。\n3PC 相比 2PC 带来了什么？ 大家都知道，3PC 相比于 2PC 来说多了两个东西：\n增加了 time out commit phase 被分割为了 prepare commit 和 do commit 两个部分 增加一个 prepare commit phase 带来了什么呢？是集群对 commit 这一决定的共识。\n在 2PC 协议中，协调者单方面向参与者发送一次 commit 消息。这个消息有两个含义：\n让参与者进行 commit 所有参与者都认可此 commit 但需要注意的是，对于一个 transaction，是 commit 还是 abort 这个决定本身只有协调者知道。一旦协调者故障，这部分信息就消失了。所以我们说 2PC 的协调者是单点故障点。\n3PC 协议中，prepare commit 消息让一个 transaction 该 commit 还是 abort 这个决定本身被传导到了所有参与者处。如此一来，如果协调者故障，参与者们可以根据 prepare commit 的情况继续工作。\n","keywords":["distributed-systems"],"articleBody":"最近在准备面试的过程中看到有这样一个问题，就是让比较一下 2PC 和 3PC。在网上找了一些文章来读，感觉都没有十分简洁地说明两者之间最基本的区别点。所以，在这里写一篇小文，表达一下自己对 2PC，3PC 最核心区别的理解。\n最重要的最先说，在我看来两者的核心区别在于：参与者间是否对 transaction commit/abort 建立了共识。3PC 的参与者之间对 commit 的成立是具有共识的，2PC 则没有。\n3PC 相比 2PC 带来了什么？ 大家都知道，3PC 相比于 2PC 来说多了两个东西：\n增加了 time out commit phase 被分割为了 prepare commit 和 do commit 两个部分 增加一个 prepare commit phase 带来了什么呢？是集群对 commit 这一决定的共识。\n在 2PC 协议中，协调者单方面向参与者发送一次 commit 消息。这个消息有两个含义：\n让参与者进行 commit 所有参与者都认可此 commit 但需要注意的是，对于一个 transaction，是 commit 还是 abort 这个决定本身只有协调者知道。一旦协调者故障，这部分信息就消失了。所以我们说 2PC 的协调者是单点故障点。\n3PC 协议中，prepare commit 消息让一个 transaction 该 commit 还是 abort 这个决定本身被传导到了所有参与者处。如此一来，如果协调者故障，参与者们可以根据 prepare commit 的情况继续工作。\n举例来说，time out 之后，我们从参与者中选出一个新的协调者。该协调者向其他参与者询问对于当前未完成 transaction 的信息。如果所有参与者都表示已经收到了 prepare commit，则证明我们可以对此 transaction 进行 commit；如果有部分参与者没有收到 prepare commit，我们可以选择 abort 或者再次尝试 commit 流程；如果谁都没有收到，则 rollback。\n2PC 的参与者为什么不能接替工作？ 读完上面的叙述中，大家可能会有疑问。明明 2PC 中的 commit 信息已经携带了所有参与者都同意 commit 的隐藏信息，为什么不能像 3PC 一样让参与者成为新的协调者继续工作呢？为了解决这个疑问，我们需要考虑一个极端情况：协调者在发送部分 commit 信息后故障，收到 commit 信息的参与者在 commit 后也发生故障。\n在这个情况下，如果剩余的参与者之一成为新的协调者，因为所有参与者都没有接收到 commit 消息，我们只能认定这个 transaction 需要被 abort。要是在此之后，之前已经 commit 的故障参与者恢复了，灾难就到来了 – 集群内各个服务器的数据不一致。\n基于以上原因，2PC 在协调者发生故障后，只能阻塞等待。因为参与者自己不能判断能否对进行着的 transaction 进行 commit 或 abort。\n3PC 则没有这个问题。同样的情况，因为只有在确认所有的参与者都收到 prepare commit 之后才会实际进行 commit。即，在可能出现 abort 决定情况下，系统中谁都还没有对此 transaction 进行 commit。所以，当故障服务器恢复后，不会有 2PC 例子中的数据不一致问题。\n3PC 的问题 敏锐的人可能发现了，上面对 3PC 参与者可以安全接替工作的表述并不是在所有的情况下都成立的。这是因为 3PC 是基于 reliable network 环境设计的。\n具体来说，如果发生了 network partition，又恰好把接收到和未接收到 prepare commit 消息的服务器们分别划到了不同的 partition 中。在 time out 后，一边会选择 commit，而另一边会选择 abort。一旦 network 重新恢复，我们也同样面对数据不一致问题。\n因为在实际的应用中，我们的网络都是不稳定的，加之 3PC 增加了一轮通信，所以很少在工程中使用。\n","wordCount":"163","inLanguage":"en","datePublished":"0001-01-01T00:00:00Z","dateModified":"2024-12-28T14:09:27+08:00","author":[{"@type":"Person","name":"Me"}],"mainEntityOfPage":{"@type":"WebPage","@id":"https://z1ggy-o.github.io/posts/2pc-vs-3pc/"},"publisher":{"@type":"Organization","name":"Gy's Blog","logo":{"@type":"ImageObject","url":"https://z1ggy-o.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://z1ggy-o.github.io/ accesskey=h title="Gy's Blog (Alt + H)">Gy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://z1ggy-o.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://z1ggy-o.github.io/weekly/ title=Logs><span>Logs</span></a></li><li><a href=https://z1ggy-o.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://z1ggy-o.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://z1ggy-o.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://z1ggy-o.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://z1ggy-o.github.io/posts/></a></div><h1 class="post-title entry-hint-parent">2PC v.s. 3PC: 一句话的总结</h1><div class=post-meta>1 min&nbsp;·&nbsp;Me</div></header><div class=post-content><p>最近在准备面试的过程中看到有这样一个问题，就是让比较一下 2PC 和 3PC。在网上找了一些文章来读，感觉都没有十分简洁地说明两者之间最基本的区别点。所以，在这里写一篇小文，表达一下自己对 2PC，3PC 最核心区别的理解。</p><p>最重要的最先说，在我看来两者的核心区别在于：<strong>参与者间是否对 transaction commit/abort 建立了共识</strong>。3PC 的参与者之间对 commit 的成立是具有共识的，2PC 则没有。</p><h2 id=3pc-相比-2pc-带来了什么>3PC 相比 2PC 带来了什么？<a hidden class=anchor aria-hidden=true href=#3pc-相比-2pc-带来了什么>#</a></h2><p>大家都知道，3PC 相比于 2PC 来说多了两个东西：</p><ol><li>增加了 time out</li><li>commit phase 被分割为了 prepare commit 和 do commit 两个部分</li></ol><p>增加一个 prepare commit phase 带来了什么呢？是集群对 commit 这一决定的共识。</p><p>在 2PC 协议中，协调者单方面向参与者发送一次 commit 消息。这个消息有两个含义：</p><ol><li>让参与者进行 commit</li><li>所有参与者都认可此 commit</li></ol><p>但需要注意的是，对于一个 transaction，是 commit 还是 abort 这个决定本身只有协调者知道。一旦协调者故障，这部分信息就消失了。所以我们说 2PC 的协调者是单点故障点。</p><p>3PC 协议中，prepare commit 消息让一个 transaction 该 commit 还是 abort 这个决定本身被传导到了所有参与者处。如此一来，如果协调者故障，参与者们可以根据 prepare commit 的情况继续工作。</p><p>举例来说，time out 之后，我们从参与者中选出一个新的协调者。该协调者向其他参与者询问对于当前未完成 transaction 的信息。如果所有参与者都表示已经收到了 prepare commit，则证明我们可以对此 transaction 进行 commit；如果有部分参与者没有收到 prepare commit，我们可以选择 abort 或者再次尝试 commit 流程；如果谁都没有收到，则 rollback。</p><h2 id=2pc-的参与者为什么不能接替工作>2PC 的参与者为什么不能接替工作？<a hidden class=anchor aria-hidden=true href=#2pc-的参与者为什么不能接替工作>#</a></h2><p>读完上面的叙述中，大家可能会有疑问。明明 2PC 中的 commit 信息已经携带了所有参与者都同意 commit 的隐藏信息，为什么不能像 3PC 一样让参与者成为新的协调者继续工作呢？为了解决这个疑问，我们需要考虑一个极端情况：协调者在发送部分 commit 信息后故障，收到 commit 信息的参与者在 commit 后也发生故障。</p><p>在这个情况下，如果剩余的参与者之一成为新的协调者，因为所有参与者都没有接收到 commit 消息，我们只能认定这个 transaction 需要被 abort。要是在此之后，之前已经 commit 的故障参与者恢复了，灾难就到来了 &ndash; 集群内各个服务器的数据不一致。</p><p>基于以上原因，2PC 在协调者发生故障后，只能阻塞等待。因为参与者自己不能判断能否对进行着的 transaction 进行 commit 或 abort。</p><p>3PC 则没有这个问题。同样的情况，因为只有在确认所有的参与者都收到 prepare commit 之后才会实际进行 commit。即，在可能出现 abort 决定情况下，系统中谁都还没有对此 transaction 进行 commit。所以，当故障服务器恢复后，不会有 2PC 例子中的数据不一致问题。</p><h2 id=3pc-的问题>3PC 的问题<a hidden class=anchor aria-hidden=true href=#3pc-的问题>#</a></h2><p>敏锐的人可能发现了，上面对 3PC 参与者可以安全接替工作的表述并不是在所有的情况下都成立的。这是因为 3PC 是基于 reliable network 环境设计的。</p><p>具体来说，如果发生了 network partition，又恰好把接收到和未接收到 prepare commit 消息的服务器们分别划到了不同的 partition 中。在 time out 后，一边会选择 commit，而另一边会选择 abort。一旦 network 重新恢复，我们也同样面对数据不一致问题。</p><p>因为在实际的应用中，我们的网络都是不稳定的，加之 3PC 增加了一轮通信，所以很少在工程中使用。</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://z1ggy-o.github.io/tags/distributed-systems/>Distributed-Systems</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://z1ggy-o.github.io/>Gy's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>