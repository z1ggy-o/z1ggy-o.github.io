<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>CMU 15-445 2021 Fall Project#3 | Gy's Blog</title>
<meta name=keywords content="DBMS"><meta name=description content="In this project, we will Implement executors for taking query plan nodes and executing them.
We are using the iterator query processing model (i.e., the Volcano model). Each executor implements a loop that continues calling Next on its children to retrieve tuples and process them one-by-one.
How executor works
Before start coding, we need to learn a lot from the related source code first. The instruction does not show all the details and I believe they did this intentionally."><meta name=author content="map[link:https://github.com/z1ggy-o name:gyzhu]"><link rel=canonical href=https://z1ggy-o.github.io/posts/projects/cmu15445-project03/><link crossorigin=anonymous href=/assets/css/stylesheet.d6fcd20a4fb86efa4dfac8ec95da60244cc8871042183da1ef28e3a762ad79c8.css integrity="sha256-1vzSCk+4bvpN+sjsldpgJEzIhxBCGD2h7yjjp2Ktecg=" rel="preload stylesheet" as=style><link rel=icon href=https://z1ggy-o.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://z1ggy-o.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://z1ggy-o.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://z1ggy-o.github.io/apple-touch-icon.png><link rel=mask-icon href=https://z1ggy-o.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://z1ggy-o.github.io/posts/projects/cmu15445-project03/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://z1ggy-o.github.io/posts/projects/cmu15445-project03/"><meta property="og:site_name" content="Gy's Blog"><meta property="og:title" content="CMU 15-445 2021 Fall Project#3"><meta property="og:description" content="In this project, we will Implement executors for taking query plan nodes and executing them.
We are using the iterator query processing model (i.e., the Volcano model). Each executor implements a loop that continues calling Next on its children to retrieve tuples and process them one-by-one.
How executor works Before start coding, we need to learn a lot from the related source code first. The instruction does not show all the details and I believe they did this intentionally."><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-04-30T12:37:56+00:00"><meta property="article:modified_time" content="2024-12-28T14:09:27+08:00"><meta property="article:tag" content="DBMS"><meta name=twitter:card content="summary"><meta name=twitter:title content="CMU 15-445 2021 Fall Project#3"><meta name=twitter:description content="In this project, we will Implement executors for taking query plan nodes and executing them.
We are using the iterator query processing model (i.e., the Volcano model). Each executor implements a loop that continues calling Next on its children to retrieve tuples and process them one-by-one.
How executor works
Before start coding, we need to learn a lot from the related source code first. The instruction does not show all the details and I believe they did this intentionally."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"","item":"https://z1ggy-o.github.io/posts/"},{"@type":"ListItem","position":2,"name":"CMU 15-445 2021 Fall Project#3","item":"https://z1ggy-o.github.io/posts/projects/cmu15445-project03/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"CMU 15-445 2021 Fall Project#3","name":"CMU 15-445 2021 Fall Project#3","description":"In this project, we will Implement executors for taking query plan nodes and executing them.\nWe are using the iterator query processing model (i.e., the Volcano model). Each executor implements a loop that continues calling Next on its children to retrieve tuples and process them one-by-one.\nHow executor works Before start coding, we need to learn a lot from the related source code first. The instruction does not show all the details and I believe they did this intentionally.\n","keywords":["DBMS"],"articleBody":"In this project, we will Implement executors for taking query plan nodes and executing them.\nWe are using the iterator query processing model (i.e., the Volcano model). Each executor implements a loop that continues calling Next on its children to retrieve tuples and process them one-by-one.\nHow executor works Before start coding, we need to learn a lot from the related source code first. The instruction does not show all the details and I believe they did this intentionally.\nAs discussed in the lecture, DBMSs will convert a SQL statement into a query plan, which is a tree consisted by operator nodes. The executors that we implement define how we process these operators.\nInside an operator, we get the expression of the operator. Thus, to implement an executor, we need to get the expression of that plan node, and evaluate these expression in the right way to get the result.\nIn this project, I recommend you to read the test code first before anything else. The test code tells us the structure of the code base and how they are combined together.\nThe plan node and execution engine are the most important components.\nExecutionEngine is defined in execution_engine.h and there is only one single API – Execute(). In this function, it calls ExecuteFactory to create executor object and return a smart pointer to the caller. There is a SetUp() function in executor_test_util.h that does all the initializations for us. That’s why we can use GetExecutionEngine() and GetExecutorContext() in the test file directly. (I was very curious about this.) Different operators have their own plan node. The executor can fetch information it needs from the passed in plan node. Thus, do check all the members of the plan node. Sequential Scan This task needs us to read a lot code to know how these components work. In short, what we need to do is read all the tuples from the TableHeap.\nOnce you know how to read a tuple from a given table, this task is almost done. However, do remember to use the output scheme to build the output tuple. Also, use the given predicate to filtrate out unsatisfied tuples.\nInsertion In this part we need to do both:\nInsert new tuples into the table Insert new indexes for these new tuples There can have several tuples to be inserted in one query, and each table can have several indexes (based on different index keys).\nAll the components that we need to insert tuples and indexes can be find through the catalog of the table. More specifically:\nWe can get table information from the catalog. Through the table information, we can get the container of the table (TableHeap), which provides the APIs to modify the table. We can get index information from the catalog. Similarly, through the index information, we can get the container of the index (Index), which provides the APIs to modify the index. Because all the APIs are provided by the code base or ourself (i.e., the underlying buffer pool management and extendible hash index), there is no much code we need to write for insertion.\nUpdate Update is very similar with insertion. As described in the project instruction, the APIs that create updated tuples has been provided, so the tuple update part is very simple.\nWe need to consider when and how to update the indexes. A hint for this is that the index of attributes in the table index is the same in the table, which means we can know if the index keys are updated.\nDelete Delete itself is very straightforward. Just delete the tuple and related indexes.\nNested Loop Join Need to read the test case code to learn how to build the joined tuples. More specifically, there are two Expressions that we need in this task, one is from the predicate, which is used for check if two tuples are matched; another is from the output schema columns, we need to use it to create the output tuples.\nHash Join Hash join is more complicated than nested loop join. The good news (?) is that, we assume the hash table can fit in the memory, so the basic hash join algorithm is enough.\nThe basic hash join algorithm has two phases: build and probe. Before we check any tuple of the inner table, we need to build the hash table for the outer table first. This phase should be done at the beginning.\nThen, for each tuple of the inner table, we can use the hash table to find the matched tuples. We need to create a hash table by ourself. This is the most difficult part. As the instruction told us, we should check SimpleAggregationHashTable to learn how to create one for hash joining. You should also check aggregation_plan.h, which contains some components that SimpleAggregationHashTable uses. This part of work may need deeper knowledge about C++ than other tasks.\nWe also need to get the hash keys using the given expressions. (P.S. the instruction in the website may not be updated. There is no GetLeftJoinKey() and GetRightJoinKey() member functions in the code base that I am using.)\nAggregation Since the hash table is given by the code base, we only need to use these expressions that the plan node gives to us. We only need to care about the GROUP BY and HAVING clauses. Aggregations are handled by the given code.\nDistinct After we know how to build our own hash table through the exercise of hash join, this task becomes quite easy. We only need to create another hash table, and use it to get distinct tuples.\nResult At the time of my submission, I was ranked first on the leaderboard. ^^\n","wordCount":"952","inLanguage":"en","datePublished":"2022-04-30T12:37:56Z","dateModified":"2024-12-28T14:09:27+08:00","author":{"@type":"Person","name":{"link":"https://github.com/z1ggy-o","name":"gyzhu"}},"mainEntityOfPage":{"@type":"WebPage","@id":"https://z1ggy-o.github.io/posts/projects/cmu15445-project03/"},"publisher":{"@type":"Organization","name":"Gy's Blog","logo":{"@type":"ImageObject","url":"https://z1ggy-o.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://z1ggy-o.github.io/ accesskey=h title="Gy's Blog (Alt + H)">Gy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://z1ggy-o.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://z1ggy-o.github.io/weekly/ title=Logs><span>Logs</span></a></li><li><a href=https://z1ggy-o.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://z1ggy-o.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://z1ggy-o.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://z1ggy-o.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://z1ggy-o.github.io/posts/></a></div><h1 class="post-title entry-hint-parent">CMU 15-445 2021 Fall Project#3</h1><div class=post-meta><span title='2022-04-30 12:37:56 +0000 UTC'>April 30, 2022</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;map[link:https://github.com/z1ggy-o name:gyzhu]</div></header><div class=post-content><p>In this project, we will Implement <strong>executors</strong> for taking query plan nodes and executing them.</p><p>We are using the iterator query processing model (i.e., the Volcano model). Each executor implements a loop that continues calling <code>Next</code> on its children to retrieve tuples and process them one-by-one.</p><h2 id=how-executor-works>How <code>executor</code> works<a hidden class=anchor aria-hidden=true href=#how-executor-works>#</a></h2><p>Before start coding, we need to learn a lot from the related source code first. The instruction does not show all the details and I believe they did this intentionally.</p><p>As discussed in the lecture, DBMSs will convert a SQL statement into a query plan, which is a tree consisted by operator nodes. The executors that we implement define how we process these operators.</p><p>Inside an operator, we get the expression of the operator. Thus, to implement an executor, we need to get the expression of that plan node, and evaluate these expression in the right way to get the result.</p><p>In this project, I recommend you to read the test code first before anything else. The test code tells us the structure of the code base and how they are combined together.</p><p>The <em>plan node</em> and <em>execution engine</em> are the most important components.</p><ul><li><code>ExecutionEngine</code> is defined in <code>execution_engine.h</code> and there is only one single API &ndash; <code>Execute()</code>. In this function, it calls <code>ExecuteFactory</code> to create executor object and return a smart pointer to the caller.</li><li>There is a <code>SetUp()</code> function in <code>executor_test_util.h</code> that does all the initializations for us. That&rsquo;s why we can use <code>GetExecutionEngine()</code> and <code>GetExecutorContext()</code> in the test file directly. (I was very curious about this.)</li><li>Different operators have their own plan node. The executor can fetch information it needs from the passed in plan node. Thus, do check all the members of the plan node.</li></ul><h2 id=sequential-scan>Sequential Scan<a hidden class=anchor aria-hidden=true href=#sequential-scan>#</a></h2><p>This task needs us to read a lot code to know how these components work. In short, what we need to do is read all the tuples from the <code>TableHeap</code>.</p><p>Once you know how to read a tuple from a given table, this task is almost done. However, do remember to use the output scheme to build the output tuple. Also, use the given predicate to filtrate out unsatisfied tuples.</p><h2 id=insertion>Insertion<a hidden class=anchor aria-hidden=true href=#insertion>#</a></h2><p>In this part we need to do both:</p><ol><li>Insert new tuples into the table</li><li>Insert new indexes for these new tuples</li></ol><p>There can have several tuples to be inserted in one query, and each table can have several indexes (based on different index keys).</p><p>All the components that we need to insert tuples and indexes can be find through the <code>catalog</code> of the table. More specifically:</p><ul><li>We can get table information from the catalog. Through the table information, we can get the container of the table (<code>TableHeap</code>), which provides the APIs to modify the table.</li><li>We can get index information from the catalog. Similarly, through the index information, we can get the container of the index (<code>Index</code>), which provides the APIs to modify the index.</li></ul><p>Because all the APIs are provided by the code base or ourself (i.e., the underlying buffer pool management and extendible hash index), there is no much code we need to write for insertion.</p><h2 id=update>Update<a hidden class=anchor aria-hidden=true href=#update>#</a></h2><p>Update is very similar with insertion. As described in the project instruction, the APIs that create updated tuples has been provided, so the tuple update part is very simple.</p><p>We need to consider when and how to update the indexes. A hint for this is that the index of attributes in the table index is the same in the table, which means we can know if the index keys are updated.</p><h2 id=delete>Delete<a hidden class=anchor aria-hidden=true href=#delete>#</a></h2><p>Delete itself is very straightforward. Just delete the tuple and related indexes.</p><h2 id=nested-loop-join>Nested Loop Join<a hidden class=anchor aria-hidden=true href=#nested-loop-join>#</a></h2><p>Need to read the test case code to learn how to build the joined tuples. More specifically, there are two <code>Expression</code>s that we need in this task, one is from the predicate, which is used for check if two tuples are matched; another is from the output schema columns, we need to use it to create the output tuples.</p><h2 id=hash-join>Hash Join<a hidden class=anchor aria-hidden=true href=#hash-join>#</a></h2><p>Hash join is more complicated than nested loop join. The good news (?) is that, we assume the hash table can fit in the memory, so the basic hash join algorithm is enough.</p><p>The basic hash join algorithm has two phases: build and probe.
Before we check any tuple of the inner table, we need to build the hash table for the outer table first. This phase should be done at the beginning.</p><p>Then, for each tuple of the inner table, we can use the hash table to find the matched tuples.
We need to create a hash table by ourself. This is the most difficult part. As the instruction told us, we should check <code>SimpleAggregationHashTable</code> to learn how to create one for hash joining. You should also check <code>aggregation_plan.h</code>, which contains some components that <code>SimpleAggregationHashTable</code> uses. This part of work may need deeper knowledge about C++ than other tasks.</p><p>We also need to get the hash keys using the given expressions. (P.S. the instruction in the website may not be updated. There is no <code>GetLeftJoinKey()</code> and <code>GetRightJoinKey()</code> member functions in the code base that I am using.)</p><h2 id=aggregation>Aggregation<a hidden class=anchor aria-hidden=true href=#aggregation>#</a></h2><p>Since the hash table is given by the code base, we only need to use these expressions that the plan node gives to us.
We only need to care about the <code>GROUP BY</code> and <code>HAVING</code> clauses. Aggregations are handled by the given code.</p><h2 id=distinct>Distinct<a hidden class=anchor aria-hidden=true href=#distinct>#</a></h2><p>After we know how to build our own hash table through the exercise of hash join, this task becomes quite easy. We only need to create another hash table, and use it to get distinct tuples.</p><h2 id=result>Result<a hidden class=anchor aria-hidden=true href=#result>#</a></h2><p><img alt=image.png loading=lazy src=https://raw.githubusercontent.com/z1ggy-o/static_resources/main/img/cmu15445-project03-grades.png>
At the time of my submission, I was ranked first on the leaderboard. ^^</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://z1ggy-o.github.io/tags/dbms/>DBMS</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://z1ggy-o.github.io/>Gy's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>