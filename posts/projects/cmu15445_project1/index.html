<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>CMU 15-445 2021 Fall Project#1 | Gy's Blog</title>
<meta name=keywords content="DBMS"><meta name=description content="
Because the course asks us to not sharing source code, here, I will only jot down some hits to help you (or maybe only me, kk) to finish the project. I will not even describe the process of any specific function, because I don&rsquo;t think that would be very different from public the source code.

Task #1 - LRU Replacement Policy
BufferPoolManger contains all the frames.
LRUReplacer is an implementation of the Replacer and it helps BufferPoolManger to manage these frames."><meta name=author content="map[link:https://github.com/z1ggy-o name:gyzhu]"><link rel=canonical href=https://z1ggy-o.github.io/posts/projects/cmu15445_project1/><link crossorigin=anonymous href=/assets/css/stylesheet.d6fcd20a4fb86efa4dfac8ec95da60244cc8871042183da1ef28e3a762ad79c8.css integrity="sha256-1vzSCk+4bvpN+sjsldpgJEzIhxBCGD2h7yjjp2Ktecg=" rel="preload stylesheet" as=style><link rel=icon href=https://z1ggy-o.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://z1ggy-o.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://z1ggy-o.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://z1ggy-o.github.io/apple-touch-icon.png><link rel=mask-icon href=https://z1ggy-o.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://z1ggy-o.github.io/posts/projects/cmu15445_project1/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://z1ggy-o.github.io/posts/projects/cmu15445_project1/"><meta property="og:site_name" content="Gy's Blog"><meta property="og:title" content="CMU 15-445 2021 Fall Project#1"><meta property="og:description" content=" Because the course asks us to not sharing source code, here, I will only jot down some hits to help you (or maybe only me, kk) to finish the project. I will not even describe the process of any specific function, because I don’t think that would be very different from public the source code.
Task #1 - LRU Replacement Policy BufferPoolManger contains all the frames. LRUReplacer is an implementation of the Replacer and it helps BufferPoolManger to manage these frames."><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-03-14T21:23:00+08:00"><meta property="article:modified_time" content="2024-12-28T14:09:27+08:00"><meta property="article:tag" content="DBMS"><meta name=twitter:card content="summary"><meta name=twitter:title content="CMU 15-445 2021 Fall Project#1"><meta name=twitter:description content="
Because the course asks us to not sharing source code, here, I will only jot down some hits to help you (or maybe only me, kk) to finish the project. I will not even describe the process of any specific function, because I don&rsquo;t think that would be very different from public the source code.

Task #1 - LRU Replacement Policy
BufferPoolManger contains all the frames.
LRUReplacer is an implementation of the Replacer and it helps BufferPoolManger to manage these frames."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"","item":"https://z1ggy-o.github.io/posts/"},{"@type":"ListItem","position":2,"name":"CMU 15-445 2021 Fall Project#1","item":"https://z1ggy-o.github.io/posts/projects/cmu15445_project1/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"CMU 15-445 2021 Fall Project#1","name":"CMU 15-445 2021 Fall Project#1","description":" Because the course asks us to not sharing source code, here, I will only jot down some hits to help you (or maybe only me, kk) to finish the project. I will not even describe the process of any specific function, because I don\u0026rsquo;t think that would be very different from public the source code.\nTask #1 - LRU Replacement Policy BufferPoolManger contains all the frames. LRUReplacer is an implementation of the Replacer and it helps BufferPoolManger to manage these frames.\n","keywords":["DBMS"],"articleBody":" Because the course asks us to not sharing source code, here, I will only jot down some hits to help you (or maybe only me, kk) to finish the project. I will not even describe the process of any specific function, because I don’t think that would be very different from public the source code.\nTask #1 - LRU Replacement Policy BufferPoolManger contains all the frames. LRUReplacer is an implementation of the Replacer and it helps BufferPoolManger to manage these frames.\nThis LRU policy is not very “LRU” in my opinion. Refer the test cases we can see, if we Unpin the same frame twice, we do not update the access time for this frame. Which means that we only need to inserte/delete page frames to/from the LRU container. There is no positon modification (assume we use conventional list + hash table implementation).\nYou may need to read the code associated with task 1 and task 2 before start programming for task 1. Thus, you can understand how BufferPoolManager utlizes the LRUReplacer.\nActually, it is the BufferPoolMangerInstance managing the pages in the buffer. The LRUReplacer itself only contains page frames that we can use for storing new pages. In other words, the reference (pin) count of pages that existed in the frames that in the LRUReplacer is zero, and we can swap them out in anytime.\nSince we need to handle the concurret access, latches (or locks) are necessary. If you are not fimilar with locks in C++ like me, you can check the include/common/rwlatch.h to learn how Bustub (i.e., the DBMS that we are implementing) uses them.\nTask #2 - Buffer Pool Manager Instance We use Page as the container to manage the pages of our DB storage engine. Page objects are pre-allocated for each frame in the buffer pool. We reuse existed Page objects instead of creating a new one for every newly read in pages.\nWe pin a page when we want to use it, and we unpin a page when we do not need it anymore. Because we are using the page, the buffer pool manager will not move this page out. Thus, pin and unpin are hints to tell the pool manager which page it can swap out if there is no free space.\nCaution, frame and page are refering to different concepts. page is a chunk of data that stored in our DBMS; frame is a slot in the page buffer that has the same size as the page. So, use frame_id_t and page_id_t at the right place.\nThe comments in the base code is not very clear. They use “page” to refer both data pages and page frames, which is confusing. Make sure which is the target that you want before coding.\nBufferPoolManager uses four components to manage pages and frames:\npage_table_: a map that stores the mapping relationship between page_id and frame_id. free_list_: a linked-list that stores the free frames. replacer_: a LRUReplacer that stores used frames with zero pin count. pages_: stores pre-allocated Page objects. In terms of concurrency control, because we only have one latch for a whole buffer, the coarse-grained lock is unavoidable.\nBufferPoolManager is the friend of Page, so we can access the private members of Page. (This is a good example about when to use friend – when we need to change some member variables but we do not want give setters so that every one can change them.)\nIf we can do three things right, this task is not that difficult:\nMove page to/from LRU. Know when to flush a page. (Read points are very clear). Which page metadata we need to update. Critical hints:\nDo read the header file and make sure your return value fits the function description. (I wasted few hours just because I returned false in a function, however, they assume we should return true in that case. Do not use your own judgement, just follow the description.) What will happen if we NewPage() then Unpin() the same page immediately? Do not use the iterator after you erased the corresponding element. The iterator is invalided, however, the compiler will not warn you. Task #3 - Parallel Buffer Pool Manager Task 3 is very straightforward. If our BufferPoolManagerInstance is implemented in the right way, the only thing we need to do here is to allocate mutiple buffer instance and call corresponding member functions for each instance.\nSome people have problems with the start index assignment and update. Please make sure you do everything right as the describtion told us.\nResult Passed all test cases with full grades.\n","wordCount":"764","inLanguage":"en","datePublished":"2022-03-14T21:23:00+08:00","dateModified":"2024-12-28T14:09:27+08:00","author":{"@type":"Person","name":{"link":"https://github.com/z1ggy-o","name":"gyzhu"}},"mainEntityOfPage":{"@type":"WebPage","@id":"https://z1ggy-o.github.io/posts/projects/cmu15445_project1/"},"publisher":{"@type":"Organization","name":"Gy's Blog","logo":{"@type":"ImageObject","url":"https://z1ggy-o.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://z1ggy-o.github.io/ accesskey=h title="Gy's Blog (Alt + H)">Gy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://z1ggy-o.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://z1ggy-o.github.io/weekly/ title=Logs><span>Logs</span></a></li><li><a href=https://z1ggy-o.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://z1ggy-o.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://z1ggy-o.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://z1ggy-o.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://z1ggy-o.github.io/posts/></a></div><h1 class="post-title entry-hint-parent">CMU 15-445 2021 Fall Project#1</h1><div class=post-meta><span title='2022-03-14 21:23:00 +0800 +0800'>March 14, 2022</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;map[link:https://github.com/z1ggy-o name:gyzhu]</div></header><div class=post-content><blockquote><p>Because the course asks us to not sharing source code, here, I will only jot down some hits to help you (or maybe only me, kk) to finish the project. I will not even describe the process of any specific function, because I don&rsquo;t think that would be very different from public the source code.</p></blockquote><h2 id=task-1---lru-replacement-policy>Task #1 - LRU Replacement Policy<a hidden class=anchor aria-hidden=true href=#task-1---lru-replacement-policy>#</a></h2><p><code>BufferPoolManger</code> contains all the frames.
<code>LRUReplacer</code> is an implementation of the <code>Replacer</code> and it helps <code>BufferPoolManger</code> to manage these frames.</p><p>This <code>LRU</code> policy is not very &ldquo;LRU&rdquo; in my opinion. Refer the test cases we can see, if we <code>Unpin</code> the same frame twice, we do not update the access time for this frame. Which means that we only need to inserte/delete page frames to/from the LRU container. There is no positon modification (assume we use conventional list + hash table implementation).</p><p>You may need to read the code associated with task 1 and task 2 before start programming for task 1. Thus, you can understand how <code>BufferPoolManager</code> utlizes the <code>LRUReplacer</code>.</p><p>Actually, it is the <code>BufferPoolMangerInstance</code> managing the pages in the buffer. The <code>LRUReplacer</code> itself only contains page frames that we can use for storing new pages.
In other words, the reference (pin) count of pages that existed in the frames that in the <code>LRUReplacer</code> is zero, and we can swap them out in anytime.</p><p>Since we need to handle the concurret access, latches (or locks) are necessary. If you are not fimilar with locks in C++ like me, you can check the <code>include/common/rwlatch.h</code> to learn how Bustub (i.e., the DBMS that we are implementing) uses them.</p><h2 id=task-2---buffer-pool-manager-instance>Task #2 - Buffer Pool Manager Instance<a hidden class=anchor aria-hidden=true href=#task-2---buffer-pool-manager-instance>#</a></h2><p>We use <code>Page</code> as the container to manage the pages of our DB storage engine. <code>Page</code> objects are pre-allocated for each frame in the buffer pool. We reuse existed <code>Page</code> objects instead of creating a new one for every newly read in pages.</p><p>We pin a page when we want to use it, and we unpin a page when we do not need it anymore. Because we are using the page, the buffer pool manager will not move this page out. Thus, pin and unpin are hints to tell the pool manager which page it can swap out if there is no free space.</p><p>Caution, <code>frame</code> and <code>page</code> are refering to different concepts. <code>page</code> is a chunk of data that stored in our DBMS; <code>frame</code> is a slot in the page buffer that has the same size as the <code>page</code>. So, use <code>frame_id_t</code> and <code>page_id_t</code> at the right place.</p><p>The comments in the base code is not very clear. They use &ldquo;page&rdquo; to refer both data pages and page frames, which is confusing. Make sure which is the target that you want before coding.</p><p><code>BufferPoolManager</code> uses four components to manage pages and frames:</p><ul><li><code>page_table_</code>: a map that stores the mapping relationship between <code>page_id</code> and <code>frame_id</code>.</li><li><code>free_list_</code>: a linked-list that stores the free frames.</li><li><code>replacer_</code>: a <code>LRUReplacer</code> that stores used frames with zero pin count.</li><li><code>pages_</code>: stores pre-allocated <code>Page</code> objects.</li></ul><p>In terms of concurrency control, because we only have one latch for a whole buffer, the coarse-grained lock is unavoidable.</p><p><code>BufferPoolManager</code> is the <code>friend</code> of <code>Page</code>, so we can access the <code>private</code> members of <code>Page</code>. (This is a good example about when to use <code>friend</code> &ndash; when we need to change some member variables but we do not want give setters so that every one can change them.)</p><p>If we can do three things right, this task is not that difficult:</p><ul><li>Move page to/from LRU.</li><li>Know when to flush a page. (Read points are very clear).</li><li>Which page metadata we need to update.</li></ul><p><strong>Critical hints:</strong></p><ul><li>Do read the header file and make sure your return value fits the function description. (I wasted few hours just because I returned <code>false</code> in a function, however, they assume we should return <code>true</code> in that case. Do not use your own judgement, just follow the description.)</li><li>What will happen if we <code>NewPage()</code> then <code>Unpin()</code> the same page immediately?</li><li>Do not use the iterator after you erased the corresponding element. The iterator is invalided, however, the compiler will not warn you.</li></ul><h2 id=task-3---parallel-buffer-pool-manager>Task #3 - Parallel Buffer Pool Manager<a hidden class=anchor aria-hidden=true href=#task-3---parallel-buffer-pool-manager>#</a></h2><p>Task 3 is very straightforward. If our <code>BufferPoolManagerInstance</code> is implemented in the right way, the only thing we need to do here is to allocate mutiple buffer instance and call corresponding member functions for each instance.</p><p>Some people have problems with the start index assignment and update. Please make sure you do everything right as the describtion told us.</p><h2 id=result>Result<a hidden class=anchor aria-hidden=true href=#result>#</a></h2><p>Passed all test cases with full grades.</p><p><img alt="Project#1 grades" loading=lazy src=https://raw.githubusercontent.com/z1ggy-o/static%5Fresources/main/img/202203142113296.png></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://z1ggy-o.github.io/tags/dbms/>DBMS</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://z1ggy-o.github.io/>Gy's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>