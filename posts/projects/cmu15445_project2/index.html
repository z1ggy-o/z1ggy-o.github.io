<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>CMU 15-445 2021 Fall Project#2 | Gy's Blog</title>
<meta name=keywords content><meta name=description content="
Because the course asks us to not sharing source code, here, I will only jot down some hits to help you (or maybe only me, kk) to finish the project. I will not even describe the process of any specific function, because I don&rsquo;t think that would be very different from public the source code.

Task #1 - Page Layouts
Because we want to persist the hash table instead of rebuild it every time, we need to design the layout that we use to store the hash table in the disks."><meta name=author content="map[link:https://github.com/z1ggy-o name:gyzhu]"><link rel=canonical href=https://z1ggy-o.github.io/posts/projects/cmu15445_project2/><link crossorigin=anonymous href=/assets/css/stylesheet.d6fcd20a4fb86efa4dfac8ec95da60244cc8871042183da1ef28e3a762ad79c8.css integrity="sha256-1vzSCk+4bvpN+sjsldpgJEzIhxBCGD2h7yjjp2Ktecg=" rel="preload stylesheet" as=style><link rel=icon href=https://z1ggy-o.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://z1ggy-o.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://z1ggy-o.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://z1ggy-o.github.io/apple-touch-icon.png><link rel=mask-icon href=https://z1ggy-o.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://z1ggy-o.github.io/posts/projects/cmu15445_project2/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://z1ggy-o.github.io/posts/projects/cmu15445_project2/"><meta property="og:site_name" content="Gy's Blog"><meta property="og:title" content="CMU 15-445 2021 Fall Project#2"><meta property="og:description" content=" Because the course asks us to not sharing source code, here, I will only jot down some hits to help you (or maybe only me, kk) to finish the project. I will not even describe the process of any specific function, because I don’t think that would be very different from public the source code.
Task #1 - Page Layouts Because we want to persist the hash table instead of rebuild it every time, we need to design the layout that we use to store the hash table in the disks."><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-03-19T15:58:46+08:00"><meta property="article:modified_time" content="2024-12-28T14:09:27+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="CMU 15-445 2021 Fall Project#2"><meta name=twitter:description content="
Because the course asks us to not sharing source code, here, I will only jot down some hits to help you (or maybe only me, kk) to finish the project. I will not even describe the process of any specific function, because I don&rsquo;t think that would be very different from public the source code.

Task #1 - Page Layouts
Because we want to persist the hash table instead of rebuild it every time, we need to design the layout that we use to store the hash table in the disks."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"","item":"https://z1ggy-o.github.io/posts/"},{"@type":"ListItem","position":2,"name":"CMU 15-445 2021 Fall Project#2","item":"https://z1ggy-o.github.io/posts/projects/cmu15445_project2/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"CMU 15-445 2021 Fall Project#2","name":"CMU 15-445 2021 Fall Project#2","description":" Because the course asks us to not sharing source code, here, I will only jot down some hits to help you (or maybe only me, kk) to finish the project. I will not even describe the process of any specific function, because I don\u0026rsquo;t think that would be very different from public the source code.\nTask #1 - Page Layouts Because we want to persist the hash table instead of rebuild it every time, we need to design the layout that we use to store the hash table in the disks.\n","keywords":[null],"articleBody":" Because the course asks us to not sharing source code, here, I will only jot down some hits to help you (or maybe only me, kk) to finish the project. I will not even describe the process of any specific function, because I don’t think that would be very different from public the source code.\nTask #1 - Page Layouts Because we want to persist the hash table instead of rebuild it every time, we need to design the layout that we use to store the hash table in the disks.\nWe have implemented the BufferPoolManager in previous project. Buffer pool itself only allocate page frame for us to use. However, which kind of Page is stored in the page frame? In this task, we need to create two kinds of Pages for our hash table:\nHash table directory page Hash table bucket page Since we are using the previous allocated memory space (we cast the data_ field of Page to directory page or bucket page), understanding of memory management and how C/C++ pointer operation works are necessary.\nFor bitwise operations, because the bitmap is based on char arrays, we can only do bitwise operations char by char (at least, this is what I find).\nHash Table Directory Page This kind of page stores metadata for the hash table. The most important part is the bucket address table.\nAt this stage, only implement the necessary functions, and they are very simple. We will come back to add more functions in the following tasks.\nHash Bucket Page Stores key-value pairs, with some metadata that helps track space usages. Here, we only support fixed-length KV pairs.\nThere are two bitmaps that we used to indicate if a slot contains valid KV:\nreadable_ occupied_ occupied_ actually has no specially meaning in extendible hashing because we do not need tombstone. However, we still need to maintain it, because there are some related test cases. I assume the teaching team still leave this part here so that they do not need to modify the test cases.\nThe page layout itself is very straightforward. Only the bitwise operations are a little annoying.\nTask #2 - Hash Table Implementation This task is very interesting because we use the buffer pool manager that we implemented previously to handle the storage part for thus. We only need to use these APIs to allocate pages and store the hash table in these pages.\nI recommend to implement the search at the very beginning then other functions, since other operations also need search to check if a specific KV pair is existed.\nSearch For a given key, we use the given hash function to get the hash value, then through the directory (bucket address table) to get the corresponding bucket page. After that, we do a sequential search to find the key.\nBecause we support duplicated keys, we need to find all the KV pairs that has the given key. Do not stop at the first matched pair.\nInsert The core components of insertion part is split. Highly recommend to use pen and paper to figure how bucket split works before coding.\nThe insertion procedure is as follows:\nFind the right bucket If there is room in the bucket, insert the KV pair If there is no room -\u003e split the bucket How to split one bucket? Assume we call the split target split bucket and the newly created bucket image bucket.\nIf $ global\\_depth == local\\_depth $:\nIncrease the global_depth by 1, so double the table size The following steps are same as situation $ global\\_depth \u003e local\\_depth $ If $global\\_depth \u003e local\\_depth$:\nAllocate a new page for the image bucket Adjust the entries in the bucket address table leave the half of the entries pointing to the split bucket set all the remaining entries to point to the image bucket also increase the local_depth by 1 because we need one more bit to separate them Rehash KV pairs in the split bucket Re-attemp the insertion Should use the Insert() function because we may need more splits Add your own test cases. The given test case is so small and cannot cover all situations.\nRemove Remove itself is very simple. The complicated part is the merge procedure. The good thing is that, after finished split, the logic of merge became clear to us.\nThe project description gives a fairly thorough instructions for merge. Follow the instruction is enough.\nShrinking the table is very straightforward since we use LSB to assign KV pairs to different buckets.\nTask #3 Concurrency Control Try coarse-grained latch (lock) first, then reduce the latch range.\nNo special comments for this. You can do it!\nResult ","wordCount":"779","inLanguage":"en","datePublished":"2022-03-19T15:58:46+08:00","dateModified":"2024-12-28T14:09:27+08:00","author":{"@type":"Person","name":{"link":"https://github.com/z1ggy-o","name":"gyzhu"}},"mainEntityOfPage":{"@type":"WebPage","@id":"https://z1ggy-o.github.io/posts/projects/cmu15445_project2/"},"publisher":{"@type":"Organization","name":"Gy's Blog","logo":{"@type":"ImageObject","url":"https://z1ggy-o.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://z1ggy-o.github.io/ accesskey=h title="Gy's Blog (Alt + H)">Gy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://z1ggy-o.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://z1ggy-o.github.io/weekly/ title=Logs><span>Logs</span></a></li><li><a href=https://z1ggy-o.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://z1ggy-o.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://z1ggy-o.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://z1ggy-o.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://z1ggy-o.github.io/posts/></a></div><h1 class="post-title entry-hint-parent">CMU 15-445 2021 Fall Project#2</h1><div class=post-meta><span title='2022-03-19 15:58:46 +0800 +0800'>March 19, 2022</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;map[link:https://github.com/z1ggy-o name:gyzhu]</div></header><div class=post-content><blockquote><p>Because the course asks us to not sharing source code, here, I will only jot down some hits to help you (or maybe only me, kk) to finish the project. I will not even describe the process of any specific function, because I don&rsquo;t think that would be very different from public the source code.</p></blockquote><h2 id=task-1---page-layouts>Task #1 - Page Layouts<a hidden class=anchor aria-hidden=true href=#task-1---page-layouts>#</a></h2><p>Because we want to persist the hash table instead of rebuild it every time, we need to design the layout that we use to store the hash table in the disks.</p><p>We have implemented the <code>BufferPoolManager</code> in previous project. Buffer pool itself only allocate page frame for us to use. However, which kind of <code>Page</code> is stored in the page frame? In this task, we need to create two kinds of <code>Page</code>s for our hash table:</p><ul><li>Hash table directory page</li><li>Hash table bucket page</li></ul><p>Since we are using the previous allocated memory space (we cast the <code>data_</code> field of <code>Page</code> to directory page or bucket page), understanding of memory management and how C/C++ pointer operation works are necessary.</p><p>For bitwise operations, because the bitmap is based on char arrays, we can only do bitwise operations char by char (at least, this is what I find).</p><h3 id=hash-table-directory-page>Hash Table Directory Page<a hidden class=anchor aria-hidden=true href=#hash-table-directory-page>#</a></h3><p>This kind of page stores metadata for the hash table. The most important part is the <strong>bucket address table</strong>.</p><p>At this stage, only implement the necessary functions, and they are very simple. We will come back to add more functions in the following tasks.</p><h3 id=hash-bucket-page>Hash Bucket Page<a hidden class=anchor aria-hidden=true href=#hash-bucket-page>#</a></h3><p>Stores key-value pairs, with some metadata that helps track space usages. Here, we only support fixed-length KV pairs.</p><p>There are two bitmaps that we used to indicate if a slot contains valid KV:</p><ul><li><code>readable_</code></li><li><code>occupied_</code></li></ul><p><code>occupied_</code> actually has no specially meaning in extendible hashing because we do not need tombstone. However, we still need to maintain it, because there are some related test cases. I assume the teaching team still leave this part here so that they do not need to modify the test cases.</p><p>The page layout itself is very straightforward. Only the bitwise operations are a little annoying.</p><h2 id=task-2---hash-table-implementation>Task #2 - Hash Table Implementation<a hidden class=anchor aria-hidden=true href=#task-2---hash-table-implementation>#</a></h2><p>This task is very interesting because we use the buffer pool manager that we implemented previously to handle the storage part for thus. We only need to use these APIs to allocate pages and store the hash table in these pages.</p><p>I recommend to implement the search at the very beginning then other functions, since other operations also need search to check if a specific KV pair is existed.</p><h3 id=search>Search<a hidden class=anchor aria-hidden=true href=#search>#</a></h3><p>For a given <code>key</code>, we use the given hash function to get the hash value, then through the directory (bucket address table) to get the corresponding bucket page. After that, we do a sequential search to find the key.</p><p>Because we support duplicated keys, we need to find all the KV pairs that has the given key. Do not stop at the first matched pair.</p><h3 id=insert>Insert<a hidden class=anchor aria-hidden=true href=#insert>#</a></h3><p>The core components of insertion part is split. Highly recommend to use pen and paper to figure how bucket split works before coding.</p><p>The insertion procedure is as follows:</p><ol><li>Find the right bucket</li><li>If there is room in the bucket, insert the KV pair</li><li>If there is no room -> split the bucket</li></ol><p>How to split one bucket? Assume we call the split target <em>split bucket</em> and the newly created bucket <em>image bucket</em>.</p><ul><li><p>If $ global\_depth == local\_depth $:</p><ul><li>Increase the <code>global_depth</code> by 1, so double the table size</li><li>The following steps are same as situation $ global\_depth > local\_depth $</li></ul></li><li><p>If $global\_depth > local\_depth$:</p><ul><li>Allocate a new page for the image bucket</li><li>Adjust the entries in the bucket address table<ul><li>leave the half of the entries pointing to the split bucket</li><li>set all the remaining entries to point to the image bucket</li><li>also increase the <code>local_depth</code> by 1 because we need one more bit to separate them</li></ul></li><li>Rehash KV pairs in the split bucket</li><li>Re-attemp the insertion<ul><li>Should use the <code>Insert()</code> function because we may need more splits</li></ul></li></ul></li></ul><p>Add your own test cases. The given test case is so small and cannot cover all situations.</p><h3 id=remove>Remove<a hidden class=anchor aria-hidden=true href=#remove>#</a></h3><p>Remove itself is very simple. The complicated part is the merge procedure. The good thing is that, after finished split, the logic of merge became clear to us.</p><p>The project description gives a fairly thorough instructions for merge. Follow the instruction is enough.</p><p>Shrinking the table is very straightforward since we use LSB to assign KV pairs to different buckets.</p><h2 id=task-3-concurrency-control>Task #3 Concurrency Control<a hidden class=anchor aria-hidden=true href=#task-3-concurrency-control>#</a></h2><p>Try coarse-grained latch (lock) first, then reduce the latch range.</p><p>No special comments for this. You can do it!</p><h2 id=result>Result<a hidden class=anchor aria-hidden=true href=#result>#</a></h2><p><img alt=grades loading=lazy src=https://raw.githubusercontent.com/z1ggy-o/static_resources/main/img/cmu15445-project02-grades.png></p></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://z1ggy-o.github.io/>Gy's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>