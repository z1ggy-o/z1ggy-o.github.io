<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>OSDI'22 - BlockFlex: Enabling Storage Harvesting with Software-Defined Flash in Modern Cloud Platforms | Gy's Blog</title>
<meta name=keywords content="storage-systems,cloud-computing"><meta name=description content="Motivation


Cloud computing system is high virtualised for higher resource utilization.
Recently, cloud providers have developed harvesting techniques to allow evictable virtual machines to use unallocated resources.


People mostly focus on how to use unallocated computing resources and memory resources, however, there is no harvesting techniques that built for storage resources.


This paper proposes a harvesting framework for storage resources that provides isolation of space, bandwidth, and data security.


Contribution


They conduct a characterization study of the storage efficiency in different cloud platforms through trace logs provided by these platforms."><meta name=author content="Gy"><link rel=canonical href=https://z1ggy-o.github.io/papers/reidys-2022-blockflexenablingstorage/><link crossorigin=anonymous href=/assets/css/stylesheet.d6fcd20a4fb86efa4dfac8ec95da60244cc8871042183da1ef28e3a762ad79c8.css integrity="sha256-1vzSCk+4bvpN+sjsldpgJEzIhxBCGD2h7yjjp2Ktecg=" rel="preload stylesheet" as=style><link rel=icon href=https://z1ggy-o.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://z1ggy-o.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://z1ggy-o.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://z1ggy-o.github.io/apple-touch-icon.png><link rel=mask-icon href=https://z1ggy-o.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://z1ggy-o.github.io/papers/reidys-2022-blockflexenablingstorage/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://z1ggy-o.github.io/papers/reidys-2022-blockflexenablingstorage/"><meta property="og:site_name" content="Gy's Blog"><meta property="og:title" content="OSDI'22 - BlockFlex: Enabling Storage Harvesting with Software-Defined Flash in Modern Cloud Platforms"><meta property="og:description" content="Motivation Cloud computing system is high virtualised for higher resource utilization. Recently, cloud providers have developed harvesting techniques to allow evictable virtual machines to use unallocated resources.
People mostly focus on how to use unallocated computing resources and memory resources, however, there is no harvesting techniques that built for storage resources.
This paper proposes a harvesting framework for storage resources that provides isolation of space, bandwidth, and data security.
Contribution They conduct a characterization study of the storage efficiency in different cloud platforms through trace logs provided by these platforms."><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="papers"><meta property="article:published_time" content="2022-08-07T11:39:27+00:00"><meta property="article:modified_time" content="2024-12-28T17:15:56+08:00"><meta property="article:tag" content="Storage-Systems"><meta property="article:tag" content="Cloud-Computing"><meta name=twitter:card content="summary"><meta name=twitter:title content="OSDI'22 - BlockFlex: Enabling Storage Harvesting with Software-Defined Flash in Modern Cloud Platforms"><meta name=twitter:description content="Motivation


Cloud computing system is high virtualised for higher resource utilization.
Recently, cloud providers have developed harvesting techniques to allow evictable virtual machines to use unallocated resources.


People mostly focus on how to use unallocated computing resources and memory resources, however, there is no harvesting techniques that built for storage resources.


This paper proposes a harvesting framework for storage resources that provides isolation of space, bandwidth, and data security.


Contribution


They conduct a characterization study of the storage efficiency in different cloud platforms through trace logs provided by these platforms."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Papers","item":"https://z1ggy-o.github.io/papers/"},{"@type":"ListItem","position":2,"name":"OSDI'22 - BlockFlex: Enabling Storage Harvesting with Software-Defined Flash in Modern Cloud Platforms","item":"https://z1ggy-o.github.io/papers/reidys-2022-blockflexenablingstorage/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"OSDI'22 - BlockFlex: Enabling Storage Harvesting with Software-Defined Flash in Modern Cloud Platforms","name":"OSDI\u002722 - BlockFlex: Enabling Storage Harvesting with Software-Defined Flash in Modern Cloud Platforms","description":"Motivation Cloud computing system is high virtualised for higher resource utilization. Recently, cloud providers have developed harvesting techniques to allow evictable virtual machines to use unallocated resources.\nPeople mostly focus on how to use unallocated computing resources and memory resources, however, there is no harvesting techniques that built for storage resources.\nThis paper proposes a harvesting framework for storage resources that provides isolation of space, bandwidth, and data security.\nContribution They conduct a characterization study of the storage efficiency in different cloud platforms through trace logs provided by these platforms.\n","keywords":["storage-systems","cloud-computing"],"articleBody":"Motivation Cloud computing system is high virtualised for higher resource utilization. Recently, cloud providers have developed harvesting techniques to allow evictable virtual machines to use unallocated resources.\nPeople mostly focus on how to use unallocated computing resources and memory resources, however, there is no harvesting techniques that built for storage resources.\nThis paper proposes a harvesting framework for storage resources that provides isolation of space, bandwidth, and data security.\nContribution They conduct a characterization study of the storage efficiency in different cloud platforms through trace logs provided by these platforms.\nThey come up a new abstraction of storage virtualization for software-defined SSDs. And base on that, they build a learning-based storage harvesting framework, BlockFlex.\nSolution First, they analyze the tracks provided by Alibaba and Google and find out that there are a lot of unused storage resources (both in capacity and bandwidth) in allocated and unallocated VMs. That’s the resource that we can use for evictable VMs temporarily.\nA SSD consists of multiple channel internally. Each channel has its own storage chips and can operate independently. In the context of SSD virtualization, software-defined SSD (SDF) allows the upper-level VM to map its virtual SSD (vSSD) to a set of flash channels. That’s how we control capacity and bandwidth allocation.\nBlockFlex proposes a new abstraction, ghost vSSD (gSSD), on top of SDF, attached to existed vSSD. A gSSD is represented by a data structure that records its bandwidth, capacity, expire time etc. gSSDs are organized by a set of linked list, each linked list contains gSSDs with bandwidth and capacity in a specific range. Because the allocation/deallocation does not happen frequently, this organization is enough for finding appropriate gSSDs efficiently.\nCreate gSSDs from unsold (unallocated) VMs\nBecause the storage usage of unsold VMs is quit stable. BlockFlex tags each unsold VM with a heuristic-based predicated duration time using the histogram of previous available times for the unsold VM with the same storage capacity. Create gSSDs from sold VMs\nSince sold VMs are currently using by clients, the heuristic-based prediction does not work well.\nBlockFlex allocates read, write, and erase operations at the block layer of each vSSD for online predictions. They choose LSTM as the models because they can do time-series predictions. The operation tracks are used to infer the bandwidth, throughput (IOPS), and current storage utilization, then these info is used as input for LSTMs.\nThere are bandwidth predictor, capacity predictor, and duration predictors. Both bandwidth predictor and capacity predictor use the same LSTM model, but with different learning rate and hidden layer size. The predicted bandwidth and capacity are then used as the input for the duration predictors.\nReclaim gSSDs\nUpon the gSSD reclamation, the corresponding entries in the address mapping table of the vSSD will be removed.\nIf a gSSD will expire soon, BlockFlex will erase the flash blocks for data safety, and remove the gSSD instance.\nEvaluation The workloads they used are TeraSort, ML Prep, PageRank, and YCSB. The capacity is ranged from around 60GB to 220GB (not much) The main takeaway It seems people trying to give more control of storage devices to the host side instead of using them as a black box. ","wordCount":"528","inLanguage":"en","datePublished":"2022-08-07T11:39:27Z","dateModified":"2024-12-28T17:15:56+08:00","author":{"@type":"Person","name":"Gy"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://z1ggy-o.github.io/papers/reidys-2022-blockflexenablingstorage/"},"publisher":{"@type":"Organization","name":"Gy's Blog","logo":{"@type":"ImageObject","url":"https://z1ggy-o.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://z1ggy-o.github.io/ accesskey=h title="Gy's Blog (Alt + H)">Gy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://z1ggy-o.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://z1ggy-o.github.io/weekly/ title=Logs><span>Logs</span></a></li><li><a href=https://z1ggy-o.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://z1ggy-o.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://z1ggy-o.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://z1ggy-o.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://z1ggy-o.github.io/papers/>Papers</a></div><h1 class="post-title entry-hint-parent">OSDI'22 - BlockFlex: Enabling Storage Harvesting with Software-Defined Flash in Modern Cloud Platforms</h1><div class=post-meta><span title='2022-08-07 11:39:27 +0000 UTC'>August 7, 2022</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Gy</div></header><div class=post-content><h2 id=motivation>Motivation<a hidden class=anchor aria-hidden=true href=#motivation>#</a></h2><ul><li><p>Cloud computing system is high virtualised for higher resource utilization.
Recently, cloud providers have developed harvesting techniques to allow evictable virtual machines to use unallocated resources.</p></li><li><p>People mostly focus on how to use unallocated computing resources and memory resources, however, there is no harvesting techniques that built for storage resources.</p></li><li><p>This paper proposes a harvesting framework for storage resources that provides isolation of space, bandwidth, and data security.</p></li></ul><h2 id=contribution>Contribution<a hidden class=anchor aria-hidden=true href=#contribution>#</a></h2><ul><li><p>They conduct a characterization study of the storage efficiency in different cloud platforms through trace logs provided by these platforms.</p></li><li><p>They come up a new abstraction of storage virtualization for software-defined SSDs. And base on that, they build a learning-based storage harvesting framework, BlockFlex.</p></li></ul><h2 id=solution>Solution<a hidden class=anchor aria-hidden=true href=#solution>#</a></h2><ul><li><p>First, they analyze the tracks provided by Alibaba and Google and find out that there are a lot of unused storage resources (both in capacity and bandwidth) in allocated and unallocated VMs. That’s the resource that we can use for evictable VMs temporarily.</p></li><li><p>A SSD consists of multiple channel internally. Each channel has its own storage chips and can operate independently. In the context of SSD virtualization, software-defined SSD (SDF) allows the upper-level VM to map its virtual SSD (vSSD) to a set of flash channels. That’s how we control capacity and bandwidth allocation.</p></li><li><p>BlockFlex proposes a new abstraction, ghost vSSD (gSSD), on top of SDF, attached to existed vSSD. A gSSD is represented by a data structure that records its bandwidth, capacity, expire time etc. gSSDs are organized by a set of linked list, each linked list contains gSSDs with bandwidth and capacity in a specific range. Because the allocation/deallocation does not happen frequently, this organization is enough for finding appropriate gSSDs efficiently.</p></li><li><p>Create gSSDs from unsold (unallocated) VMs</p><ul><li>Because the storage usage of unsold VMs is quit stable. BlockFlex tags each unsold VM with a heuristic-based predicated duration time using the histogram of previous available times for the unsold VM with the same storage capacity.</li></ul></li><li><p>Create gSSDs from sold VMs</p><ul><li><p>Since sold VMs are currently using by clients, the heuristic-based prediction does not work well.</p></li><li><p>BlockFlex allocates read, write, and erase operations at the block layer of each vSSD for online predictions. They choose LSTM as the models because they can do time-series predictions. The operation tracks are used to infer the bandwidth, throughput (IOPS), and current storage utilization, then these info is used as input for LSTMs.</p></li><li><p>There are bandwidth predictor, capacity predictor, and duration predictors. Both bandwidth predictor and capacity predictor use the same LSTM model, but with different learning rate and hidden layer size. The predicted bandwidth and capacity are then used as the input for the duration predictors.</p></li></ul></li><li><p>Reclaim gSSDs</p><ul><li><p>Upon the gSSD reclamation, the corresponding entries in the address mapping table of the vSSD will be removed.</p></li><li><p>If a gSSD will expire soon, BlockFlex will erase the flash blocks for data safety, and remove the gSSD instance.</p></li></ul></li></ul><h2 id=evaluation>Evaluation<a hidden class=anchor aria-hidden=true href=#evaluation>#</a></h2><ul><li>The workloads they used are TeraSort, ML Prep, PageRank, and YCSB. The capacity is ranged from around 60GB to 220GB (not much)</li></ul><h2 id=the-main-takeaway>The main takeaway<a hidden class=anchor aria-hidden=true href=#the-main-takeaway>#</a></h2><ul><li>It seems people trying to give more control of storage devices to the host side instead of using them as a black box.</li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://z1ggy-o.github.io/tags/storage-systems/>Storage-Systems</a></li><li><a href=https://z1ggy-o.github.io/tags/cloud-computing/>Cloud-Computing</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://z1ggy-o.github.io/>Gy's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>