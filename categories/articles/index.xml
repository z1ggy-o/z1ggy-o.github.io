<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Articles on Gy's Blog</title><link>https://z1ggy-o.github.io/categories/articles/</link><description>Recent content in Articles on Gy's Blog</description><generator>Hugo -- 0.140.1</generator><language>en-us</language><lastBuildDate>Sat, 28 Dec 2024 15:56:52 +0000</lastBuildDate><atom:link href="https://z1ggy-o.github.io/categories/articles/index.xml" rel="self" type="application/rss+xml"/><item><title>LevelDB 源码分析笔记</title><link>https://z1ggy-o.github.io/posts/leveldb-analysis/</link><pubDate>Mon, 22 Aug 2022 13:30:19 +0000</pubDate><guid>https://z1ggy-o.github.io/posts/leveldb-analysis/</guid><description>&lt;p>最近一周花了些时间阅读了 LevelDB 的代码，了解一下 LSM-Tree 的具体实现。在阅读的过程中简略的记录了一些笔记，放在了我的 &lt;a href="https://github.com/z1ggy-o/LevelDB-Notes/tree/main/Notes">Github repo&lt;/a> 里。笔记是用蹩脚英语写的，也没有做任何的插图，建议配合&lt;a href="https://leveldb-handbook.readthedocs.io/zh/latest/basic.html">此分析文档&lt;/a>一起食用。&lt;/p></description></item><item><title>Note - x86 汇编语言（4）：分页机制</title><link>https://z1ggy-o.github.io/books/x86-assembly-shuangwang/04.x86%E6%B1%87%E7%BC%96%E7%AC%94%E8%AE%B0%E7%AC%AC%E5%9B%9B%E9%83%A8%E5%88%86/</link><pubDate>Sun, 10 Jul 2022 08:39:25 +0000</pubDate><guid>https://z1ggy-o.github.io/books/x86-assembly-shuangwang/04.x86%E6%B1%87%E7%BC%96%E7%AC%94%E8%AE%B0%E7%AC%AC%E5%9B%9B%E9%83%A8%E5%88%86/</guid><description>&lt;hr>
&lt;p>到了该系列笔记的最后一个章节了。之前的几个章节中，我们讨论了最直白的 8086 分段访问模型，又讲到了保护模式下的分段访问模式，现在我们来讲一讲实际生活中的默认内存管理方式&amp;ndash;分页。&lt;/p></description></item><item><title>Note - x86 汇编语言（3）：多任务支持</title><link>https://z1ggy-o.github.io/books/x86-assembly-shuangwang/03.x86%E6%B1%87%E7%BC%96%E7%AC%94%E8%AE%B0%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86/</link><pubDate>Wed, 06 Jul 2022 08:44:20 +0000</pubDate><guid>https://z1ggy-o.github.io/books/x86-assembly-shuangwang/03.x86%E6%B1%87%E7%BC%96%E7%AC%94%E8%AE%B0%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86/</guid><description>&lt;hr>
&lt;p>这是系列笔记的第三篇。在上一篇中，我们介绍了保护模式基于段选择子的寻址方式，这一篇中我们来讲一讲该架构的另一个特点，多任务支持。&lt;/p>
&lt;p>其余章节如下：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="../01.x86%E6%B1%87%E7%BC%96%E7%AC%94%E8%AE%B0%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86/">第一部分: 计算机基础和实模式&lt;/a>&lt;/li>
&lt;li>&lt;a href="02.x86%E6%B1%87%E7%BC%96%E7%AC%94%E8%AE%B0%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86/">第二部分：保护模式下的分段寻址和权限&lt;/a>&lt;/li>
&lt;li>&lt;a href="03.x86%E6%B1%87%E7%BC%96%E7%AC%94%E8%AE%B0%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86/">第三部分：多任务支持&lt;/a>&lt;/li>
&lt;li>&lt;a href="04.x86%E6%B1%87%E7%BC%96%E7%AC%94%E8%AE%B0%E7%AC%AC%E5%9B%9B%E9%83%A8%E5%88%86/">第四部分：分页机制&lt;/a>&lt;/li>
&lt;/ul>
&lt;h2 id="任务运行程序的表达">任务：运行程序的表达&lt;/h2>
&lt;p>在之前的篇章中我们尽量避免了任务概念的出现。在 80286 之前，计算机主要以单任务（single-tasking）的方式运行。即，先集中于完成一个程序的运行，再运行下一个程序。有些类似于最初 mainframe 的 batching 的感觉。80286 首次在处理器硬件上提供了对多任务的支持，80386 时期多任务得到了广泛的应用。&lt;/p></description></item><item><title>Note - x86 汇编语言（2）：保护模式下的分段寻址方法和权限设计</title><link>https://z1ggy-o.github.io/books/x86-assembly-shuangwang/02.x86%E6%B1%87%E7%BC%96%E7%AC%94%E8%AE%B0%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86/</link><pubDate>Tue, 05 Jul 2022 09:16:52 +0000</pubDate><guid>https://z1ggy-o.github.io/books/x86-assembly-shuangwang/02.x86%E6%B1%87%E7%BC%96%E7%AC%94%E8%AE%B0%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86/</guid><description>&lt;hr>
&lt;p>这是本系列笔记的第二个部分。这个部分里，我们来看一看保护模式的一大改变——寻址方法，以及配合而来的保护功能。另一个大改变是对多任务的支持，我们在之后的篇章里再谈。&lt;/p></description></item><item><title>Note - x86 汇编语言（1）：计算机基础和实模式</title><link>https://z1ggy-o.github.io/books/x86-assembly-shuangwang/01.x86%E6%B1%87%E7%BC%96%E7%AC%94%E8%AE%B0%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86/</link><pubDate>Sun, 03 Jul 2022 09:29:01 +0000</pubDate><guid>https://z1ggy-o.github.io/books/x86-assembly-shuangwang/01.x86%E6%B1%87%E7%BC%96%E7%AC%94%E8%AE%B0%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86/</guid><description>&lt;hr>
&lt;p>最近读完了《x86 汇编语言：从实模式到保护模式》一书。感觉此书是了解 Intel 架构 CPU 运行方式的好材料。所以，我准备用四个篇章来写一份读书笔记，简略地介绍一下内存寻址方式，以及处理器对多任务的支持。笔记的内容意在指出书中的框架重点，作为一个快速复习和检索的工具，而非详实的内容。&lt;/p></description></item><item><title>幻读，到底是怎么一回事儿</title><link>https://z1ggy-o.github.io/posts/isolation-levels-and-phtantom/</link><pubDate>Thu, 12 May 2022 07:11:54 +0000</pubDate><guid>https://z1ggy-o.github.io/posts/isolation-levels-and-phtantom/</guid><description>&lt;p>幻读 (phantom phenomenon) 是数据库使用中经常提到的一个问题。一个常见的面试问题就是：某个数据库，在某个 isolation level 下，会不会出现幻读，以及其解决方法。&lt;/p>
&lt;p>网上有许多关于幻读的文章，但是在读完之后发现，大多数的说明都浮于表面，好像作者们自己也并没有弄清楚幻读的本质。在本文中，我想利用数据库的一些高层抽象概念，来阐述幻读的本质。虽然不涉及任何的具体实现，但相信你在了解到这些概念之后，可以很快地理解幻读，以及各种幻读的处理方法。&lt;/p></description></item></channel></rss>